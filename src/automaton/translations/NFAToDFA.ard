\import Data.List
\import Logic
\import Logic.Meta
\import Paths.Meta
\import automaton.DFA
\import automaton.Language
\import automaton.NFA \hiding (Action, End, State, delta, isEnd, start)
\import sets.DecidableSet
\import sets.Elements
\import sets.MySet
\import sets.finite.Sized
\open DecSizedEnsemble (pow)

\func NFAtoDFA (nfa : NFA) : DFA \cowith
  | Action => nfa.Action
  | State => nfa.State.pow
  | delta Q a q' => ∃ (q : nfa.State) (q ∈ Q) (nfa.delta (q, a, q'))
  | start => DecSizedEnsemble.singleSized nfa.start
  | End Q => Any Q nfa.End
  | isEnd => {?}
  \where {
    \func respectsLanguage {nfa : NFA} : NFA.language nfa = DFA.language (NFAtoDFA nfa) =>
      ext (\lam w => ext (helper1 w (DecSizedEnsemble.singleSized nfa.start) idp,
                          \case helper2 w  (DecSizedEnsemble.singleSized nfa.start) __ \with {
                            | inP ((_, idp), proof) => proof
                          }))

    \func helper1 {nfa : NFA} (w : Word nfa.Action) {q : nfa.State}
                  (Q : nfa.State.pow) (el : q ∈ Q)
                  (l : NFA.accepts nfa q w)
      : DFA.accepts (NFAtoDFA nfa) Q w \elim w, l
      | nil, NFA.isLast e => DFA.isLast (inP ((q, el), e))
      | :: a tail, NFA.isStep q' d l => DFA.isStep (helper1 tail {q'}
          (DFA.delta {NFAtoDFA nfa} Q a) (inP (q, el, d)) l)

    \func helper2 {nfa : NFA} (w : Word nfa.Action)
                  (Q : nfa.State.pow)
                  (l : DFA.accepts (NFAtoDFA nfa) Q w)
      : ∃ (q : Elements Q) (NFA.accepts nfa q.1 w) \elim w, l
      | nil, DFA.isLast (inP (q, e)) => inP (q, NFA.isLast e)
      | :: a tail, DFA.isStep l => \case helper2 tail (delta {NFAtoDFA nfa} Q a) l \with {
        | inP ((q', inP (q, qQ, d)), h) => inP ((q, qQ), NFA.isStep q' d h)
      }
  }