\import Arith.Nat
\import Data.Bool
\import Data.List
\import Data.Or
\import DualNumbers
\import Function
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import automaton.Language
\import automaton.Regular
\import identity.OrIdentity
\import sets.MySet
\import sets.union
\import util.Or

\record NFAeps
  | Action : \Set
  | State : \Set
  | delta : (\Sigma State (Label Action) State) -> \Prop
  | start : State
  | End : State -> \Prop

  \where {
    \data Label (A : \Set)
      | epsilon
      | action A

    \truncated \data accepts (d : NFAeps) (q : d.State) (u : Word d.Action) : \Prop \elim u
      | nil => isLast (d.End q)
      | :: a tail => isStep (q' : d.State) (d.delta (q, action a, q')) (accepts d q' tail)
      | w => isEps (q' : d.State) (d.delta (q, epsilon, q')) (accepts d q' w)

    \func language (nfae : NFAeps) : Language (nfae.Action) => accepts nfae nfae.start

    \data run (d : NFAeps) (from to : d.State) (w : Word d.Action) \elim w
      | nil => noStep (from = to)
      | :: a tail => oneStep (q : d.State) (d.delta (from, action a, q)) (run d q to tail)
      | w => oneEps (q : d.State) (d.delta (from, epsilon, q)) (run d q to w)

      \where {
        \func toAccepts {d : NFAeps} {w : Word d.Action} {q q' : d.State}
                        (h : run d q q' w)
                        (e : d.End q')
          : accepts d q w
        \elim w, h
          | nil, noStep idp => isLast e
          | :: a tail, oneStep q'' de h => isStep q'' de (toAccepts h e)
          | w, oneEps q'' de h => isEps q'' de (toAccepts h e)
      }

    \data CombinedState (State State' : \Set)
      | startState
      | leftState State
      | rightState State'

    \func noneNFAeps {A : Alphabet} : NFAeps { | Action => A } \cowith
      | State => \Sigma
      | delta => ∅
      | start => ()
      | End => ∅
      \where {
        \func hasNoWords {A : Alphabet} {w : Word A} (h : w ∈ language noneNFAeps) : Empty
        \elim w, h
          | nil, isLast e => e
          | :: a tail, isStep q' d a1 => d
          | w, isEps q' d a => d
      }

    \func singleNFAeps {A : Alphabet} (a : A) : NFAeps { | Action => A } \cowith
      | State => Bool
      | delta => \case __ \with {
        | (false, action x, true) => x = a
        | _ => Empty
      }
      | start => false
      | End => So
      \where {
        \func singleInLanguage {A : Alphabet} {a : A} : (a :: nil) ∈ language (singleNFAeps a) =>
          isStep true idp (isLast so)

        \func onlySingleInLanguage {A : Alphabet} {w : Word A} {a : A} (h : w ∈ language (singleNFAeps a))
          : a :: nil = w
        \elim w, h
          | :: x nil, isStep true idp (isLast e) => idp
          | :: x nil, isStep true idp (isEps _ () _)
          | :: x nil, isEps _ () _
          | :: x nil, isStep false () _
          | nil, isLast ()
          | nil, isEps _ () _
          | :: x (:: y l), isStep false () h
          | :: x (:: y l), isStep true idp (isStep _ () _)
          | :: x (:: y l), isStep true idp (isEps _ () _)
          | :: x (:: y l), isEps false () _
          | :: x (:: y l), isEps true () _
      }

    \func concat {A : Alphabet} (a b : NFAeps { | Action => A }) : NFAeps { | Action => A } \cowith
      | State => CombinedState a.State b.State
      | delta qxq' => \case \elim qxq' \with {
        | (startState, epsilon, leftState q') => q' = a.start
        | (leftState q, x, leftState q') => a.delta (q, x, q')
        | (leftState q, epsilon, rightState q') => \Sigma (a.End q) (q' = b.start)
        | (rightState q, x, rightState q') => b.delta (q, x, q')
        | _ => Empty
      }
      | start => startState
      | End q => \case q \with {
        | startState => Empty
        | leftState s => Empty
        | rightState s => b.End s
      }
      \where {
        \func concatInLangauge {A : Alphabet} {a b : NFAeps { | Action => A }} {w w' : Word A}
                               (h : w ∈ language a) (h' : w' ∈ language b) : (w ++ w') ∈ language (concat a b) =>
          isEps (leftState a.start) idp (acceptsLeft a.start h h')

        \func acceptsLeft {A : Alphabet} {a b : NFAeps { | Action => A }} {w w' : Word A} (q : a.State)
                          (h : accepts a q w) (h' : w' ∈ language b) : accepts (concat a b) (leftState q) (w ++ w')
        \elim w, h
          | nil, isLast e => isEps (rightState b.start) (e, idp) (acceptsRight b.start h')
          | :: a1 tail, isStep q' d h => isStep (leftState q') d (acceptsLeft q' h h')
          | w, isEps q' d h => isEps (leftState q') d (acceptsLeft q' h h')

        \func acceptsRight {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (q : b.State)
                           (h : accepts b q w) : accepts (concat a b) (rightState q) w
        \elim w, h
          | nil, isLast e => isLast e
          | :: a1 tail, isStep q' d h => isStep (rightState q') d (acceptsRight q' h)
          | w, isEps q' d h => isEps (rightState q') d (acceptsRight q' h)

        \func splitLanguage {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A}
                            (h : w ∈ language (concat a b))
          : ∃ (v v' : Word A) (w = v ++ v') (v ∈ language a) (v' ∈ language b) \elim w, h
          | w, isEps (leftState _) idp h => splitLeft a.start h
          | nil, isLast ()
          | :: a1 tail, isStep startState () a2
          | :: a1 tail, isStep (leftState s) () a2
          | :: a1 tail, isStep (rightState s) () a2
          | w, isEps startState () a1
          | w, isEps (rightState s) () a1
          \where {
            \func splitLeft {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A}
                            (q : a.State)
                            (h : accepts (concat a b) (leftState q) w)
              : ∃ (v v' : Word A) (w = v ++ v') (accepts a q v) (v' ∈ language b) \elim w, h
              | :: x tail, isStep (leftState s) d h => \case splitLeft s h \with {
                | inP (v,v',p,h',e) => inP (x :: v, v', pmap (x :: __) p, isStep s d h', e)
              }
              | w, isEps (leftState s) d h => \case splitLeft s h \with {
                | inP (v,v',p,h',e) => inP (v, v', p, isEps s d h', e)
              }
              | w, isEps (rightState s) (d, idp) h => inP (nil, w, idp, isLast d, splitRight s h)

              | nil, isLast ()
              | w, isEps startState () h
              | :: a1 tail, isStep startState () h
              | :: a1 tail, isStep (rightState s) () h

            \func splitRight {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A}
                             (q : b.State)
                             (h : accepts (concat a b) (rightState q) w)
              : (accepts b q w) \elim w, h
              | nil, isLast e => isLast e
              | :: a1 tail, isStep (rightState s) d h => isStep s d (splitRight s h)
              | w, isEps (rightState s) d h => isEps s d (splitRight s h)
              | w, isEps startState () h
              | w, isEps (leftState s) () h
              | :: a1 tail, isStep startState () h
              | :: a1 tail, isStep (leftState s) () h
          }
      }

    \func choice {A : Alphabet} (a b : NFAeps { | Action => A }) : NFAeps { | Action => A } \cowith
      | State => CombinedState a.State b.State
      | delta qxq' => \case \elim qxq' \with {
        | (startState, epsilon, leftState q') => q' = a.start
        | (startState, epsilon, rightState q') => q' = b.start
        | (leftState q, x, leftState q') => a.delta (q, x, q')
        | (rightState q, x, rightState q') => b.delta (q, x, q')
        | _ => Empty
      }
      | start => startState
      | End q => \case q \with {
        | startState => Empty
        | leftState s => a.End s
        | rightState s => b.End s
      }
      \where {
        \func leftInLanguage {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (h : w ∈ language a)
          : w ∈ language (choice a b) => isEps (leftState a.start) idp (leftAccepts a.start h)
          \where {
            \func leftAccepts {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (q : a.State) (h : accepts a q w)
              : accepts (choice a b) (leftState q) w \elim w, h
              | nil, isLast e => isLast e
              | :: x tail, isStep q' d h => isStep (leftState q') d (leftAccepts q' h)
              | w, isEps q' d h => isEps (leftState q') d (leftAccepts q' h)
          }

        \func rightInLanguage {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (h : w ∈ language b)
          : w ∈ language (choice a b) => isEps (rightState b.start) idp (rightAccepts b.start h)
          \where {
            \func rightAccepts {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (q : b.State) (h : accepts b q w)
              : accepts (choice a b) (rightState q) w \elim w, h
              | nil, isLast e => isLast e
              | :: x tail, isStep q' d h => isStep (rightState q') d (rightAccepts q' h)
              | w, isEps q' d h => isEps (rightState q') d (rightAccepts q' h)
          }

        \func inLanguage {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A}
                         (h : w ∈ language (choice a b)) : w ∈ language a || w ∈ language b
        \elim w, h
          | nil, isLast e => absurd e
          | :: a1 tail, isStep q' d a2 => absurd d
          | w, isEps startState d a1 => absurd d
          | w, isEps (leftState s) idp h => byLeft (inLanguageLeft h)
          | w, isEps (rightState s) idp h => byRight (inLanguageRight h)

        \func inLanguageLeft {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A}
                             {q : a.State}
                             (h : accepts (choice a b) (leftState q) w) : accepts a q w
        \elim w, h
          | nil, isLast e => isLast e
          | :: a1 tail, isStep (leftState s) d h => isStep s d (inLanguageLeft h)
          | w, isEps (leftState s) d h => isEps s d (inLanguageLeft h)

          | :: a1 tail, isStep startState () h
          | :: a1 tail, isStep (rightState s) () h
          | w, isEps startState () h
          | w, isEps (rightState s) () h

        \func inLanguageRight {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A}
                              {q : b.State}
                              (h : accepts (choice a b) (rightState q) w) : accepts b q w
        \elim w, h
          | nil, isLast e => isLast e
          | :: a1 tail, isStep (rightState s) d h => isStep s d (inLanguageRight h)
          | w, isEps (rightState s) d h => isEps s d (inLanguageRight h)

          | :: a1 tail, isStep startState () h
          | :: a1 tail, isStep (leftState s) () h
          | w, isEps startState () h
          | w, isEps (leftState s) () h
      }

    \func starEps {A : Alphabet} (a : NFAeps { | Action => A }) : NFAeps { | Action => A } \cowith
      | State => a.State
      | delta (q, x, q') =>
        a.delta (q, x, q') ||
        (\Sigma (x = epsilon) (a.End q) (q' = a.start))
      | start => a.start
      | End => single a.start

      \where {
        \func nilInLanguage {A : Alphabet} {a : NFAeps { | Action => A }} : nil ∈ language (starEps a) => isLast idp

        \func origianalInLanguage {A : Alphabet} {a : NFAeps { | Action => A }} {w : Word A} (h : w ∈ language a) : w ∈ language (starEps a) =>
          origianalAccepts h
          \where {
            \func origianalAccepts {A : Alphabet} {a : NFAeps { | Action => A }} {w : Word A} {q : a.State} (h : accepts a q w) : accepts (starEps a) q w
            \elim w, h
              | nil, isLast e => isEps a.start (byRight (idp, e, idp)) (isLast idp)
              | :: a1 tail, isStep q' d h => isStep q' (byLeft d) (origianalAccepts h)
              | w, isEps q' d h => isEps q' (byLeft d) (origianalAccepts h)
          }

        \func addOneInLanguage {A : Alphabet} {a : NFAeps { | Action => A }} {w w' : Word A}
                               (h : w ∈ language a) (h' : w' ∈ language (starEps a))
          : (w ++ w') ∈ language (starEps a) => addOneAccepts h h'
          \where {
            \func addOneAccepts {A : Alphabet} {a : NFAeps { | Action => A }}
                                {q : a.State}
                                {w w' : Word A}
                                (h : accepts a q w) (h' : w' ∈ language (starEps a))
              : accepts (starEps a) q (w ++ w') \elim w, h
              | nil, isLast e => isEps a.start (byRight (idp, e, idp)) h'
              | :: x tail, isStep q' d h => isStep q' (byLeft d) (addOneAccepts h h')
              | w, isEps q' d h => isEps q' (byLeft d) (addOneAccepts h h')
          }

        \func inLanguageIsStar {A : Alphabet} {a : NFAeps { | Action => A }} {w : Word A}
                               (h : w ∈ language (starEps a))
          : w ∈ Language.star (language a) => {?} -- termination is quite tricky
      }

    \use \coerce fromRegularExpression {A : Alphabet} (re : RegularExpression A) : NFAeps { | Action => A } \elim re
      | none => noneNFAeps
      | alpha a => singleNFAeps a
      | + a b => choice (fromRegularExpression a) (fromRegularExpression b)
      | ⋅ a b => concat (fromRegularExpression a) (fromRegularExpression b)
      | * a => starEps (fromRegularExpression a)

      \where {
        \func respectsLanguage {A : Alphabet} {re : RegularExpression A}
          : RegularExpression.language re = language (fromRegularExpression re) =>
          ext (\lam w => ext (helper1 re w, helper2 re w))

        \func helper1 {A : Alphabet} (re : RegularExpression A) (w : Word A) (h : RegularExpression.language re w)
          : language (fromRegularExpression re) w \elim re, h
          | alpha a, idp => singleNFAeps.singleInLanguage
          | + a b, byLeft h => choice.leftInLanguage (helper1 a w h)
          | + a b, byRight h => choice.rightInLanguage (helper1 b w h)
          | ⋅ a b, inP (v, v', idp, h, h') => concat.concatInLangauge (helper1 a v h) (helper1 b v' h')
          | * re, byRight idp => starEps.nilInLanguage
          | * re, byLeft (inP (0, c)) => starEps.origianalInLanguage (helper1 re w c)
          | * re, byLeft (inP (suc n, inP (v,v', idp, e,e'))) => starEps.addOneInLanguage (helper1 re v e) (helper1 (* re) v' (byLeft (inP (n, e'))))

        \func helper2 {A : Alphabet} (re : RegularExpression A) (w : Word A) (h : language (fromRegularExpression re) w)
          : RegularExpression.language re w
        \elim re
          | none => noneNFAeps.hasNoWords h
          | alpha a => singleNFAeps.onlySingleInLanguage h
          | + a b => \case choice.inLanguage h \with {
            | byLeft x => byLeft (helper2 a w x)
            | byRight x => byRight (helper2 b w x)
          }
          | ⋅ a b => \case concat.splitLanguage h \with {
            | inP (v, v', p, e, e') => inP (v, v', p, helper2 a v e, helper2 b v' e')
          }
          | * re => rewrite respectsLanguage (starEps.inLanguageIsStar h)
      }
  }