\import Arith.Nat
\import Data.Bool
\import Data.List
\import Data.Or
\import Function
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import automaton.Language
\import automaton.Regular
\import identity.OrIdentity
\import sets.MySet
\import sets.union
\import util.Or
\open NFAeps.choice.leftInLanguage (leftAccepts)

\record NFAeps
  | Action : \Set
  | State : \Set
  | delta : (\Sigma State (Label Action) State) -> \Prop
  | start : State
  | End : State -> \Prop

  \where {
    \data Label (A : \Set)
      | epsilon
      | action A

    \truncated \data accepts (d : NFAeps) (q : d.State) (u : Word d.Action) : \Prop \elim u
      | nil => isLast (d.End q)
      | :: a tail => isStep (q' : d.State) (d.delta (q, action a, q')) (accepts d q' tail)
      | w => isEps (q' : d.State) (d.delta (q, epsilon, q')) (accepts d q' w)

    \func language (nfae : NFAeps) : Language (nfae.Action) => accepts nfae nfae.start

    \data run (d : NFAeps) (from to : d.State) (w : Word d.Action) \elim w
      | nil => noStep (from = to)
      | :: a tail => oneStep (q : d.State) (d.delta (from, action a, q)) (run d q to tail)
      | w => oneEps (q : d.State) (d.delta (from, epsilon, q)) (run d q to w)

      \where {
        \func toAccepts {d : NFAeps} {w : Word d.Action} {q q' : d.State}
                        (h : run d q q' w)
                        (e : d.End q')
          : accepts d q w
        \elim w, h
          | nil, noStep idp => isLast e
          | :: a tail, oneStep q'' de h => isStep q'' de (toAccepts h e)
          | w, oneEps q'' de h => isEps q'' de (toAccepts h e)
      }

    \data CombinedState (State State' : \Set)
      | startState
      | leftState State
      | rightState State'

    \func noneNFAeps {A : Alphabet} : NFAeps { | Action => A } \cowith
      | State => \Sigma
      | delta => ∅
      | start => ()
      | End => ∅
    \where {
      \func hasNoWords {A : Alphabet} {w : Word A} (h : w ∈ language noneNFAeps) : Empty
        \elim w, h
          | nil, isLast e => e
          | :: a tail, isStep q' d a1 => d
          | w, isEps q' d a => d
    }

    \func singleNFAeps {A : Alphabet} (a : A) : NFAeps { | Action => A } \cowith
      | State => Bool
      | delta => \case __ \with {
        | (false, action x, true) => x = a
        | _ => Empty
      }
      | start => false
      | End => So
    \where {
      \func singleInLanguage {A : Alphabet} {a : A} : (a :: nil) ∈ language (singleNFAeps a)
        => isStep true idp (isLast so)

      \func onlySingleInLanguage {A : Alphabet} {w : Word A} {a : A} (h : w ∈ language (singleNFAeps a))
        : a :: nil = w
        \elim w, h
          | :: x nil, isStep true idp (isLast e) => idp
          | :: x nil, isStep true idp (isEps _ () _)
          | :: x nil, isEps _ () _
          | :: x nil, isStep false () _
          | nil, isLast ()
          | nil, isEps _ () _
          | :: x (:: y l), isStep false () h
          | :: x (:: y l), isStep true idp (isStep _ () _)
          | :: x (:: y l), isStep true idp (isEps  _ () _)
          | :: x (:: y l), isEps false () _
          | :: x (:: y l), isEps true () _
    }

    \func concat {A : Alphabet} (a b : NFAeps { | Action => A }) : NFAeps { | Action => A } \cowith
      | State => CombinedState a.State b.State
      | delta qxq' => \case \elim qxq' \with {
        | (startState, epsilon, leftState q') => q' = a.start
        | (leftState q, x, leftState q') => a.delta (q, x, q')
        | (leftState q, epsilon, rightState q') => \Sigma (a.End q) (q' = b.start)
        | (rightState q, x, rightState q') => b.delta (q, x, q')
        | _ => Empty
      }
      | start => startState
      | End q => \case q \with {
        | startState => Empty
        | leftState s => Empty
        | rightState s => b.End s
      }
    \where {
      \func concatInLangauge {A : Alphabet} {a b : NFAeps { | Action => A }} {w w' : Word A}
                             (h : w ∈ language a) (h' : w' ∈ language b) : (w ++ w') ∈ language (concat a b)
        => isEps (leftState a.start) idp (acceptsLeft a.start h h')

      \func acceptsLeft {A : Alphabet} {a b : NFAeps { | Action => A }} {w w' : Word A} (q : a.State)
                        (h : accepts a q w) (h' : w' ∈ language b) : accepts (concat a b) (leftState q) (w ++ w')
        \elim w, h
          | nil, isLast e => isEps (rightState b.start) (e, idp) (acceptsRight b.start h')
          | :: a1 tail, isStep q' d h => isStep (leftState q') d (acceptsLeft q' h h')
          | w, isEps q' d h => isEps (leftState q') d (acceptsLeft q' h h')

      \func acceptsRight {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (q : b.State)
                         (h : accepts b q w) : accepts (concat a b) (rightState q) w
        \elim w, h
          | nil, isLast e => isLast e
          | :: a1 tail, isStep q' d h => isStep (rightState q') d (acceptsRight q' h)
          | w, isEps q' d h => isEps (rightState q') d (acceptsRight q' h)
    }

    \func choice {A : Alphabet} (a b : NFAeps { | Action => A }) : NFAeps { | Action => A } \cowith
      | State => CombinedState a.State b.State
      | delta qxq' => \case \elim qxq' \with {
        | (startState, epsilon, leftState q') => q' = a.start
        | (startState, epsilon, rightState q') => q' = b.start
        | (leftState q, x, leftState q') => a.delta (q, x, q')
        | (rightState q, x, rightState q') => b.delta (q, x, q')
        | _ => Empty
      }
      | start => startState
      | End q => \case q \with {
        | startState => Empty
        | leftState s => a.End s
        | rightState s => b.End s
      }
    \where {
      \func leftInLanguage {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (h : w ∈ language a)
        : w ∈ language (choice a b)
        => isEps (leftState a.start) idp (leftAccepts a.start h)
      \where {
        \func leftAccepts {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (q : a.State) (h : accepts a q w)
          : accepts (choice a b) (leftState q) w \elim w, h
          | nil, isLast e => isLast e
          | :: x tail, isStep q' d h => isStep (leftState q') d (leftAccepts q' h)
          | w, isEps q' d h => isEps (leftState q') d (leftAccepts q' h)
      }

      \func rightInLanguage {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (h : w ∈ language b)
        : w ∈ language (choice a b)
        => isEps (rightState b.start) idp (rightAccepts b.start h)
        \where {
          \func rightAccepts {A : Alphabet} {a b : NFAeps { | Action => A }} {w : Word A} (q : b.State) (h : accepts b q w)
            : accepts (choice a b) (rightState q) w \elim w, h
            | nil, isLast e => isLast e
            | :: x tail, isStep q' d h => isStep (rightState q') d (rightAccepts q' h)
            | w, isEps q' d h => isEps (rightState q') d (rightAccepts q' h)
        }
    }

    \use \coerce fromRegularExpression {A : Alphabet} (re : RegularExpression A) : NFAeps { | Action => A } \elim re
      | none => noneNFAeps
      | alpha a => singleNFAeps a
      | + a b => choice (fromRegularExpression a) (fromRegularExpression b)
      | ⋅ a b => concat (fromRegularExpression a) (fromRegularExpression b)
      | * a => {?}

      \where {
        \func respectsLanguage {A : Alphabet} {re : RegularExpression A}
          : RegularExpression.language re = language (fromRegularExpression re) =>
          ext (\lam w => ext (helper1 re w, helper2 re w))

        \func helper1 {A : Alphabet} (re : RegularExpression A) (w : Word A) (h : RegularExpression.language re w)
                      : language (fromRegularExpression re) w \elim re, h
          | alpha a, idp => singleNFAeps.singleInLanguage
          | + a b, byLeft h => choice.leftInLanguage (helper1 a w h)
          | + a b, byRight h => choice.rightInLanguage (helper1 b w h)
          | ⋅ a b, inP (v, v', idp, h, h') => concat.concatInLangauge (helper1 a v h) (helper1 b v' h')
          | * re, byLeft h => {?}
          | * re, byRight h => {?}

        \func helper2 {A : Alphabet} (re : RegularExpression A) (w : Word A) (h : language (fromRegularExpression re) w)
          : RegularExpression.language re w \elim re
          | none => noneNFAeps.hasNoWords h
          | alpha a => singleNFAeps.onlySingleInLanguage h
          | + a re => {?}
          | ⋅ a re => {?}
          | * re => {?}
      }
  }