\import Equiv
\import Function.Meta
\import Meta
\import Paths
\import Paths.Meta
\import lambda.GeneralContext
\import logik.fol.FOL

\func TermContext : \Set => Context (\Sigma)
  \where {
    \func equalNat : TermContext = Nat => ext (\new QEquiv {
      | f => Context.length
      | ret => contextOfLength
      | ret_f => ret
      | f_sec => sec
    })

    \func contextOfLength (n : Nat) : TermContext \elim n
      | 0 => ∅
      | suc n => contextOfLength n ∕ ()

    \func ret (c : TermContext) : contextOfLength (Context.length c) = c \elim c
      | ∅ => idp
      | ∕ c () => pmap (__ ∕ ()) (ret c)

    \func sec (n : Nat) : Context.length (contextOfLength n) = n \elim n
      | 0 => idp
      | suc n => pmap suc (sec n)
  }

\func TermSubst {L : Language} : \Pi (_ _ : Context (\Sigma)) -> \Type => Subst {\Sigma} {\lam c _ => Term c}

\instance FOLTermSub {L : Language} : SubstOperations
  | Type => \Sigma
  | Term c _ => Term c
  | s-var {_} {()} l => var l
  | rename r t => rename r t
  | extends s t => extends s t
  | subst s t => subst s t
  \where {
    \func rename {L : Language} {gamma delta : Context (\Sigma)} (r : Rename gamma delta) (t : Term gamma) : Term delta
    \elim t
      | var f => var $ r f
      | apply f d => apply f (\lam i => rename r (d i))

    \func extends {L : Language} {gamma delta : Context (\Sigma)} (s : TermSubst gamma delta) {A : \Sigma}
      : TermSubst (gamma ∕ A) (delta ∕ A) => \lam {B} l => \case \elim A, \elim B, \elim l \with {
      | (), (), Z p => var (Z idp)
      | (), (), S l => rename S (s l)
    }

    \func subst {L : Language} {gamma delta : TermContext} (s : TermSubst gamma delta) (t : Term gamma) : Term delta
    \elim t
      | var f => s f
      | apply f d => apply f (\lam i => subst s (d i))

    \func subTermId {L : Language} {gamma : TermContext} (t : Term gamma) : subst (\lam {A} l => var l) t = t \elim t
      | var f => idp
      | apply f d => pmap (apply f) (ext $ ext (\lam j => subTermId (d j)))

    \func substRename {L : Language} {gamma delta epsiolon : TermContext}
                      {s : TermSubst delta epsiolon} {re : Rename gamma delta} (x : Term gamma)
      : FOLTermSub.subst s (FOLTermSub.rename re x) = FOLTermSub.subst (\lam {A} l => s (re l)) x
    \elim x
      | var v => idp
      | apply f d => pmap (apply f) (ext $ ext (\lam j => substRename (d j)))

    \func varSubst=rename {L : Language} {gamma delta : TermContext}
                          {s : TermSubst gamma delta} {r : Rename gamma delta}
                          (h : \Pi (l : gamma ∋ ()) -> s l = var (r l))
                          {t : Term gamma} : subst s t = rename r t \elim t
      | var v => h v
      | apply f d => pmap (apply f) (ext $ ext (\lam j => varSubst=rename h {d j}))
  }

\module FormulaSubst \where {
  \func subst {L : Language} {gamma delta : TermContext} (s : TermSubst gamma delta) (f : Formula gamma)
    : Formula delta
  \elim f
    | equal x y => equal (FOLTermSub.subst s x) (FOLTermSub.subst s y)
    | atomic r d => atomic r (\lam i => FOLTermSub.subst s (d i))
    | x impH f => subst s x impH subst s f
    | notH f => notH (subst s f)
    | forallH f => forallH (subst (FOLTermSub.extends s) f)

  \func rename {L : Language} {gamma delta : TermContext} (re : Rename gamma delta) (f : Formula gamma)
    : Formula delta \elim f
    | equal x y => equal (FOLTermSub.rename re x) (FOLTermSub.rename re y)
    | atomic r d => atomic r (\lam i => FOLTermSub.rename re (d i))
    | x impH f => rename re x impH rename re f
    | notH f => notH (rename re f)
    | forallH f => forallH (rename (extend re) f)

  \func substFormulaId {L : Language} {gamma : TermContext}
                       {f : Formula gamma} : subst (\lam {A} l => var l) f = f
  \elim f
    | equal x y => pmap2 equal (FOLTermSub.subTermId x) (FOLTermSub.subTermId y)
    | atomic r d => pmap (atomic r) (ext $ ext (\lam j => FOLTermSub.subTermId (d j)))
    | x impH f => pmap2 (impH) substFormulaId substFormulaId
    | notH f => pmap notH substFormulaId
    | forallH f =>
      \let p : FOLTermSub.extends (\lam {A} => var) = {TermSubst (gamma ∕ ()) (gamma ∕ ())} (\lam {A} => var) =>
        ext (\lam {A} l => cases l idp)
      \in transportInv (\lam s => forallH (subst s f) = forallH f) p (pmap forallH substFormulaId)

  \func substRename {L : Language} {gamma delta epsilon : TermContext}
                    {s : TermSubst delta epsilon} {re : Rename gamma delta}
                    {f : Formula gamma}
    : subst s (rename re f) = subst (\lam l => s (re l)) f
  \elim f
    | equal x y => pmap2 equal (FOLTermSub.substRename x) (FOLTermSub.substRename y)
    | atomic r d => pmap (atomic r) (ext $ ext (\lam j => FOLTermSub.substRename (d j)))
    | x impH f => pmap2 (impH) substRename substRename
    | notH f => pmap notH substRename
    | forallH f => pmap forallH (
      \let p : (\lam {A} l => FOLTermSub.extends s (extend re l)) = FOLTermSub.extends (\lam {A} l => s (re l))
      => ext (\lam {A} l => cases l idp)
      \in substRename *> pmap (subst __ f) p
    )

  \lemma varSubst=rename {L : Language} {gamma delta : TermContext}
                         {s : TermSubst gamma delta} {r : Rename gamma delta}
                         (h : \Pi (l : gamma ∋ ()) -> s l = var (r l))
                         {f : Formula gamma}
    : subst s f = rename r f \elim f
    | equal x y => pmap2 equal (FOLTermSub.varSubst=rename h) (FOLTermSub.varSubst=rename h)
    | atomic r1 d => pmap (atomic r1) (ext $ ext (\lam j => FOLTermSub.varSubst=rename h))
    | x impH f => pmap2 (impH) (varSubst=rename h) (varSubst=rename h)
    | notH f => pmap notH (varSubst=rename h)
    | forallH f => pmap forallH (varSubst=rename (\lam (l : (gamma ∕ ()) ∋ ()) => \case \elim l \with {
      | Z p => idp
      | S l => unfold (extend, FOLTermSub.extends) $ rewrite (h l) idp
    }))

  \func sub {L : Language} {gamma : TermContext}
            (f : Formula (gamma ∕ ())) (t : Term gamma) : Formula gamma => subst (subOne t) f
    \where {
      \func subOne {L : Language} {gamma : TermContext} (t : Term gamma) : TermSubst (gamma ∕ ()) gamma =>
        \case \elim __ \with {
          | Z _ => t
          | S l => var l
        }
    }

  \func sub3 {L : Language} {gamma : TermContext}
             (f : Formula (gamma ∕ () ∕ () ∕ ()))
             (t t' t'' : Term gamma) : Formula gamma => subst (extends3 t t' t'') f
    \where {
      \func extends3 {L : Language} {gamma : TermContext}
                     (t t' t'' : Term gamma) : TermSubst (gamma ∕ () ∕ () ∕ ()) gamma => \case \elim __ \with {
        | Z _ => t
        | S (Z _) => t'
        | S (S (Z _)) => t''
        | S (S (S l)) => var l
      }
    }
}