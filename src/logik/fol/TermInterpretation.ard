\import Function.Meta
\import Logic
\import Meta
\import Paths.Meta
\import Relation.Equivalence
\import Util
\import logik.fol.FOL
\import logik.fol.Semantics
\import logik.fol.SequentCalculus
\import logik.fol.Substitution
\import logik.fol.TermCongruence
\import sets.MySet
\open Semantics (Interpretation, evaluate)
\open SequentCalulus (⊢)

\func TermUniverse {L : Language} {c : TermContext} (axioms : Ensemble (Formula c)) => Quotient {Term c} (~ {T~ axioms})

\func TermArrayUniverse {L : Language} {c : TermContext} (axioms : Ensemble (Formula c)) (l : Nat) =>
  Quotient {Array (Term c) l} (\lam f g => \Pi (i : Fin l) -> f i ~ {T~ axioms} g i)

\func TermInterpretation {L : Language} {c : TermContext} (axioms : Ensemble (Formula c)) : Interpretation c =>
  (\new Semantics.Structure {
     | Universe => TermUniverse axioms
     | rel => relInterpretation axioms
     | funcs => funcInterpretation axioms
   },
   \lam f => in~ (var f))
  \where {
    \func relInterpretation {L : Language} {c : TermContext} (axioms : Ensemble (Formula c))
                            (r : Relations) (d : Array (TermUniverse axioms) (relationsArity r)) : \Prop =>
      relInterpretation' axioms r
          (Quotient.liftArray (\lam {j} => ~ {T~ axioms}) (\lam {j} x => ~-reflexive {T~ axioms}) d)

    \func relInterpretation' {L : Language} {c : TermContext} (axioms : Ensemble (Formula c)) (r : Relations)
                             (d : TermArrayUniverse axioms (relationsArity r)) : \Prop
    \elim d
      | in~ d => TruncP (axioms ⊢ atomic r d)
      | ~-equiv x y rxy => ext
          (\case \elim __, truncMap rxy \with {
            | inP rx, inP eq => inP $ ⊢.EqualRel eq rx
          },
           \case \elim __, truncMap rxy \with {
             | inP ry, inP eq => inP $ ⊢.EqualRel (\lam i => ⊢.E-Symm (eq i)) ry
           })

    \func funcInterpretation {L : Language} {c : TermContext} (axioms : Ensemble (Formula c))
                             (f : L.Functions) (d : Array (TermUniverse axioms) (L.functionArity f))
      : TermUniverse axioms =>
      funcInterpretation' f (Quotient.liftArray (\lam {j} => ~ {T~ axioms}) (\lam {j} x => ~-reflexive {T~ axioms}) d)

    \func funcInterpretation' {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                              (f : L.Functions) (d : TermArrayUniverse axioms (functionArity f))
      : TermUniverse axioms
    \elim d
      | in~ d => in~ (apply f d)
      | ~-equiv d d' r => ~-equiv {_} {~ {T~ axioms}}
          (apply f d)
          (apply f d')
          (\case truncMap r \with {
            | inP eq => inP (⊢.EqualApply eq)
          })

    \func termInterpretationIsQuotient {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)} (t : Term c)
      : evaluate (TermInterpretation axioms) t = in~ t \elim t
      | var f => idp
      | apply f d =>
        \let
          | p : (\new Array (TermUniverse axioms) (L.functionArity f) (\lam j => evaluate (TermInterpretation axioms) (d j))) =
                (\new Array (TermUniverse axioms) (L.functionArity f) (\lam j => in~ (d j))) =>
            ext (idp, ext (\lam j => termInterpretationIsQuotient (d j)))
          | goal : funcInterpretation' f
              (Quotient.liftArray
                  (\lam {j} => ~ {T~ axioms})
                  (\lam {j} x => ~-reflexive {T~ axioms})
                  (\new Array (TermUniverse axioms) (L.functionArity f) (\lam j => evaluate (TermInterpretation axioms) (d j)))
              )
            = in~ (apply f d)
          => {?}
          | goal' : funcInterpretation' f
              (Quotient.liftArray
                  (\lam {j} => ~ {T~ axioms})
                  (\lam {j} x => ~-reflexive {T~ axioms})
                  (\new Array (TermUniverse axioms) (L.functionArity f) (\lam j => in~ (d j)))
              )
            = in~ (apply f d)
          => {?}
        \in goal
    --
--    \func termInterpretationEquivForAtomics {L : Language} {c : TermContext}
    --                                            {phi : Formula n}
    --                                            {axioms : Ensemble (Formula n)}
    --      -- TruncP because there could be many proofs?
    --      : (TermInterpretation axioms ⊧ phi) = TruncP (axioms ⊢ phi)
    --    \elim phi
    --      | equal x y =>
    --        (TermInterpretation axioms ⊧ equal x y) ==< idp >==
    --        (evaluate (TermInterpretation axioms) x = evaluate (TermInterpretation axioms) y) ==< pmap2 (=) termInterpretationIsQuotient termInterpretationIsQuotient >==
    --        (in~ x = {Quotient {Term n} (~ {T~ axioms})} in~ y) ==< quotientHelper >==
    --        (x ~ {T~ axioms} y) ==< idp >==
    --        TruncP (axioms ⊢ equal x y) `qed
    --
--      | atomic r d =>
    --        (TermInterpretation axioms ⊧ atomic r d) ==< idp >==
    --        relInterpretation axioms r (\lam j => evaluate (TermInterpretation axioms) (d j))
    --          ==<
    --        pmap {Array (Quotient (~)) (L.relationsArity r)} (relInterpretation _ _) {\lam j => evaluate (TermInterpretation axioms) (d j)} {\lam j => in~ (d j)}
    --            (ext (ext (\lam j => termInterpretationIsQuotient)))
    --          >==
    --        relInterpretation axioms r (\lam j => in~ (d j)) ==< {?} >==
    --        TruncP (axioms ⊢ atomic r d) `qed
    --
--      | x impH phi => ext
    --          (\lam m => {?},
    --           \lam t m => rewrite termInterpretationEquivForAtomics (inP (⊢.MP {?} {?} {?})))
    --      | notH phi => {?}
    --      | forallH phi => {?}
  }