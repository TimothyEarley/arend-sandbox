\import Arith.Nat
\import Equiv
\import Logic
\import Logic.Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set
\import lambda.GeneralContext
\import logik.fol.Semantics
\import logik.fol.Substitution
\import sets.MySet \hiding (S, ∅)
\open Semantics (Interpretation, ⊧, ⊭)

-- http://r6.ca/Goedel/goedel1.html

\class Language
  | Relations : \Set
  | relationsArity : Relations -> Nat
  | Functions : \Set
  | functionArity : Functions -> Nat

\class DecLanguage \extends Language
  | decRelations : DecSet Relations
  | decFunctions : DecSet Functions

\func variable (c : TermContext) : \Set => c ∋ ()
  \where {
    \func equalFin {c : TermContext} : variable c = Fin (Context.length c) => ext (\new QEquiv {
      | f => ∋.toIndexFin
      | ret => ∋.fromIndexFin
      | ret_f => fromToIndexFin
      | f_sec => ∋.toFromIndexFin
    })

    \func fromToIndexFin {c : TermContext} (x : variable c) : ∋.fromIndexFin (∋.toIndexFin x) = x
    \elim c, x
      | ∕ c1 head, Z idp => idp
      | ∕ c1 head, S l => pmap S (fromToIndexFin l)

    \func funcEqualsArray {c : TermContext} {A : \Type} : (variable c -> A) = Array A (Context.length c) =>
      pmap (__ -> A) equalFin *> ext (\new QEquiv {
        | f a => a
        | ret a => a
        | ret_f _ => idp
        | f_sec x => ext idp
      })
  }

\data Term {L : Language} (c : TermContext) : \Set
  | var (variable c)
  | apply (f : L.Functions) (Array (Term {L} c) (functionArity f))

  \where {
    \func FreeVar {L : Language} {c : TermContext} (t : Term c) (i : variable c) : \Prop
    \elim t
      | var f => f = i
      | apply f d => AnyFreeVar d i

    \func AnyFreeVar {L : Language} {c : TermContext} (ts : Array (Term c)) (i : variable c) : \Prop =>
      ∃ (j : Fin ts.len) (FreeVar (ts j) i)

    \func termDepth {L : Language} {c : TermContext} (t : Term c) : Nat \elim t
      | var f => 0
      | apply f d => suc (maxTermDepth d)
      \where {
        \func maxTermDepth {L : Language} {c : TermContext} (ts : Array (Term c)) : Nat \elim ts
          | nil => 0
          | :: a arr => termDepth a ∨ maxTermDepth arr

        \lemma maxTermDepthIsBigger {L : Language} {c : TermContext} {ts : Array (Term c)} {j : Fin ts.len} : termDepth (ts j) <= maxTermDepth ts
        \elim ts, j
          | :: a arr, 0 => join-left
          | :: a arr, suc j => <=-transitive maxTermDepthIsBigger join-right
      }
  }

\data Formula {L : Language} (variables : TermContext) : \Set
  | equal (x y : Term {L} variables)
  | atomic (r : L.Relations) (Array (Term {L} variables) (L.relationsArity r))
  | \infixl 6 impH (x y : Formula {L} variables)
  | notH (x : Formula {L} variables)
  | forallH (x : Formula {L} (variables ∕ ()))
  \where {

    \func FreeVar {L : Language} {c : TermContext} (f : Formula c) (i : variable c) : \Prop \elim f
      | equal x y => Term.FreeVar x i || Term.FreeVar y i
      | atomic r d => Term.AnyFreeVar d i
      | impH x f => FreeVar x i || FreeVar f i
      | notH f => FreeVar f i
      | forallH f => FreeVar f (S i)
  }

-- x --> y = y or not x

\cons existsH {L : Language} {c : TermContext} (x : Formula {L} (c ∕ ())) : Formula {L} c
  => notH (forallH (notH x))

\cons \infix 6 orH {L : Language} {c : TermContext} (x y : Formula {L} c) : Formula {L} c
=> notH x impH y
  \where {
    \lemma or1 {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊧ x) : I ⊧ x orH y =>
      \lam m => absurd (m h)

    \lemma or2 {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊧ y) : I ⊧ x orH y =>
      \lam m => h

    \lemma or3 {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊭ x) (h' : I ⊭ y) : I ⊭ x orH y =>
      \lam m => h' (m h)
  }

\cons \infix 6 andH {L : Language} {c : TermContext} (x y : Formula c) : Formula c
=> notH (notH x orH notH y)
  \where {
    \lemma and1  {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊧ x) (h' : I ⊧ y) : I ⊧ x andH y =>
      \lam m => m (__ h) h'

    \lemma and2  {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊭ x) : I ⊭ x andH y =>
      \lam m => m (\lam m1 m2 => m1 (\lam m3 => h m3))

    \lemma and3  {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊭ y) : I ⊭ x andH y =>
      \lam m => m (\lam m1 m2 => h m2)
  }

\func \infix 7 <->H {L : Language} {c : TermContext} (x y : Formula c) : Formula c => (x impH y) andH (y impH x)

\func System {L : Language} => Ensemble (Formula {L} ∅)

