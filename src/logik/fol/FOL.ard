\import Arith.Nat
\import Equiv
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set
\import lambda.GeneralContext
\import logik.fol.Semantics
\import logik.fol.Substitution
\import sets.MySet \hiding (S, ∅)
\import util.ArrayUtils
\open Semantics (Interpretation, ⊧, ⊭)

-- http://r6.ca/Goedel/goedel1.html

\class Language
  | Relations : \Set
  | relationsArity : Relations -> Nat
  | Functions : \Set
  | functionArity : Functions -> Nat

\class DecLanguage \extends Language
  | decRelations : DecSet Relations
  | decFunctions : DecSet Functions

\func variable (c : TermContext) : \Set => c ∋ ()
  \where {
    \func equalFin {c : TermContext} : variable c = Fin (Context.length c) => ext (\new QEquiv {
      | f => ∋.toIndexFin
      | ret => ∋.fromIndexFin
      | ret_f => fromToIndexFin
      | f_sec => ∋.toFromIndexFin
    })

    \func fromToIndexFin {c : TermContext} (x : variable c) : ∋.fromIndexFin (∋.toIndexFin x) = x
    \elim c, x
      | ∕ c1 head, Z idp => idp
      | ∕ c1 head, S l => pmap S (fromToIndexFin l)

    \func funcEqualsArray {c : TermContext} {A : \Type} : (variable c -> A) = Array A (Context.length c) =>
      pmap (__ -> A) equalFin *> ext (\new QEquiv {
        | f a => a
        | ret a => a
        | ret_f _ => idp
        | f_sec x => ext idp
      })
  }

\data Term {L : Language} (c : TermContext) : \Set
  | var (variable c)
  | apply (f : L.Functions) (Array (Term {L} c) (functionArity f))

  \where {
    \func FreeVar {L : Language} {c : TermContext} (t : Term c) (i : variable c) : \Prop
    \elim t
      | var f => f = i
      | apply f d => AnyFreeVar d i

    \func AnyFreeVar {L : Language} {c : TermContext} (ts : Array (Term c)) (i : variable c) : \Prop =>
      ∃ (j : Fin ts.len) (FreeVar (ts j) i)

    \func termDepth {L : Language} {c : TermContext} (t : Term c) : Nat \elim t
      | var f => 0
      | apply f d => suc (maxTermDepth d)
      \where {
        \func maxTermDepth {L : Language} {c : TermContext} (ts : Array (Term c)) : Nat \elim ts
          | nil => 0
          | :: a arr => termDepth a ∨ maxTermDepth arr

        \lemma maxTermDepthIsBigger {L : Language} {c : TermContext} {ts : Array (Term c)} {j : Fin ts.len} : termDepth (ts j) <= maxTermDepth ts
        \elim ts, j
          | :: a arr, 0 => join-left
          | :: a arr, suc j => <=-transitive maxTermDepthIsBigger join-right
      }

    \func lift {L : Language} {c : TermContext} (t : Term c) : Term (c ∕ ()) => FOLTermSub.rename {L} {c} {c ∕ ()} S t

    \func subLift {L : Language} {c : TermContext} {t t' : Term c} : sub {FOLTermSub} {c} (lift t) t' = {Term c} t
    \elim t
      | var v => idp
      | apply f d => pmap (apply f) (ext $ ext (\lam j => subLift {L} {c} {d j}))

    \func liftN {L : Language} {c : TermContext} (t : Term c) {n : Nat} : Term (c Context.∕∕ ArrayUtils.arrayOf' () {n})
      \elim n
        | 0 => t
        | suc n => lift (liftN t)
    \where {
      \func matches1 {L : Language} {c : TermContext} {t : Term c}  : lift t = liftN t {1}
        => idp
    }

    \func subLiftN {L : Language} {c : TermContext} {t : Term c} {n : Nat} {t' : Array (Term c) n}  :
      subN {FOLTermSub} {c} {_} {ArrayUtils.arrayOf' () {n}} (liftN t {n}) t' = {Term c} t
      \elim n, t'
        | 0, nil => FOLTermSub.subTermId t
        | suc n, a :: t' => \let foo => subLiftN {L} {c} {t} {n} {t'}
          | bar : subN.extendsN {FOLTermSub {L}} {c} {() :: ArrayUtils.arrayOf' {\Sigma} () {n}} (a :: t') = {?} => {?}
                            \in {?}




    --    \func lifts {L : Language} {n l : Nat} (t : Array (Term n) l) : Array (Term (suc n)) l \elim l, t
    --      | 0, nil => nil
    --      | suc l, :: a arr => lift a :: lifts arr
    --
--    \func liftN {L : Language} {n : Nat} (k : Nat) (t : Term n) : Term (n Nat.+ k) \elim k
    --      | 0 => t
    --      | suc k => lift (liftN k t)
    --
--    \func liftNL {L : Language} {n : Nat} (k : Nat) (t : Term n) : Term (k Nat.+ n) \elim k
    --      | 0 => t
    --      | suc k => lift (liftNL k t)
    --
--    \func liftsN  {L : Language} {n l : Nat} (k : Nat) (t : Array (Term n) l) : Array (Term (n Nat.+ k)) l =>
    --      map (liftN k) t
  }

\data Formula {L : Language} (variables : TermContext) : \Set
  | equal (x y : Term {L} variables)
  | atomic (r : L.Relations) (Array (Term {L} variables) (L.relationsArity r))
  | \infixl 6 impH (x y : Formula {L} variables)
  | notH (x : Formula {L} variables)
  | forallH (x : Formula {L} (variables ∕ ()))
  \where {

    \func FreeVar {L : Language} {c : TermContext} (f : Formula c) (i : variable c) : \Prop \elim f
      | equal x y => Term.FreeVar x i || Term.FreeVar y i
      | atomic r d => Term.AnyFreeVar d i
      | impH x f => FreeVar x i || FreeVar f i
      | notH f => FreeVar f i
      | forallH f => FreeVar f (S i)

        \func lift {L : Language} {c : TermContext} (f : Formula c) : Formula (c ∕ ())
          => FormulaSubst.subst (\lam {A} l => var (S l)) f

  }

-- x --> y = y or not x

\cons existsH {L : Language} {c : TermContext} (x : Formula {L} (c ∕ ())) : Formula {L} c
  => notH (forallH (notH x))

\cons \infix 6 orH {L : Language} {c : TermContext} (x y : Formula {L} c) : Formula {L} c
=> notH x impH y
  \where {
    \lemma or1 {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊧ x) : I ⊧ x orH y =>
      \lam m => absurd (m h)

    \lemma or2 {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊧ y) : I ⊧ x orH y =>
      \lam m => h

    \lemma or3 {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊭ x) (h' : I ⊭ y) : I ⊭ x orH y =>
      \lam m => h' (m h)
  }

\cons \infix 6 andH {L : Language} {c : TermContext} (x y : Formula c) : Formula c
=> notH (notH x orH notH y)
  \where {
    \lemma and1  {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊧ x) (h' : I ⊧ y) : I ⊧ x andH y =>
      \lam m => m (__ h) h'

    \lemma and2  {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊭ x) : I ⊭ x andH y =>
      \lam m => m (\lam m1 m2 => m1 (\lam m3 => h m3))

    \lemma and3  {L : Language} {c : TermContext} {x y : Formula c} {I : Interpretation c} (h : I ⊭ y) : I ⊭ x andH y =>
      \lam m => m (\lam m1 m2 => h m2)
  }

\func \infix 7 <->H {L : Language} {c : TermContext} (x y : Formula c) : Formula c => (x impH y) andH (y impH x)

\func System {L : Language} => Ensemble (Formula {L} ∅)

