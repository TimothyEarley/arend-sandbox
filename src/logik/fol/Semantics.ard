\import Arith.Nat
\import LeipnizEquality
\import Logic
\import Logic.Meta
\import LogicUtil
\import Meta
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import lambda.Reduction
\import logik.fol.FOL
\import util.ArrayUtils
\open NatSemiring (+-comm)
\open Formula (Subst, subst)
\open DArray (!!)
\open Term (AnyFreeVar, FreeVar, termDepth)

\module Semantics \where {
  \record Structure (L : Language)
    | Universe : \Set
    | rel : \Pi (r : Relations) (args : Array Universe (relationsArity r)) -> \Prop
    | funcs : \Pi (f : Functions) (args : Array Universe (functionArity f)) -> Universe

  \func Interpretation {L : Language} (n : Nat) => \Sigma (S : Structure L) (Fin n -> S.Universe)
    \where {
      \func subst {L : Language} {n m : Nat} (I : Interpretation n) (s : Subst m n) : Interpretation m =>
        (I.1, \lam f => evaluate I (s f))
    }

  \func evaluate {L : Language} {n : Nat} (I : Interpretation n) (t : Term n) : Universe {I.1} \elim t
    | var i => I.2 i
    | apply f d => funcs {I.1} f (\lam j => evaluate I (d j))

  \func models \alias \infix 4 ⊧ {L : Language} {n : Nat} (I : Interpretation n) (f : Formula n) : \Prop \elim f
    | equal x y => evaluate I x = evaluate I y
    | atomic r d => rel {I.1} r (\lam j => evaluate I (d j))
    | impH x y => (I ⊧ x) -> (I ⊧ y)
    | notH f => Not (I ⊧ f)
    | forallH f => \Pi (x : Universe {I.1}) -> (I.1, \case __ \with {
      | 0 => x
      | suc i => I.2 i
    }) ⊧ f

  \func notModels \alias \infix 4 ⊭ {L : Language} {n : Nat} (I : Interpretation n) (f : Formula n) : \Prop =>
    Not (I ⊧ f)

  \func modelImplies \alias \infix 6 ⊫f {L : Language} {n : Nat} (x y : Formula n) : \Prop =>
    \Pi (I : Interpretation n) (I ⊧ x) -> I ⊧ y

  \func substitutionLemma {L : Language} {n : Nat}
                          (phi : Formula n) (ts : Array (Term 0) n)
                          (I : Interpretation 0) :
    (I ⊧ subst (ts !! __) phi) <-> (Interpretation.subst I (ts !! __) ⊧ phi) => (substitutionLemma->, {?})

    \where {
      \func coincidenceLemma {L : Language} {n : Nat} {U : \Set}
                             {S1 S2 : Structure L U}
                             {a1 a2 : Fin n -> U}
                             {t : Term n}
                             (h1 : \Pi (f : L.Functions) -> S1.funcs f = S2.funcs f)
                             (h2 : \Pi {i : Fin n} (free : FreeVar t i) -> a1 i = a2 i)
        -- easy termination check
                             {depth : Nat} (rh : termDepth t <= depth)
        : evaluate (S1, a1) t = evaluate (S2, a2) t
      \elim t, depth
        | var f, depth => h2 idp
        | apply f d, 0 => absurd (rh NatSemiring.zero<suc)
        | apply f d, suc depth =>
          \let p : (\lam j => evaluate (S1, a1) (d j)) = {Array U (functionArity f)} (\lam j => evaluate (S2, a2) (d j))
          => ext (ext (\lam j => coincidenceLemma h1 (\lam {i} free => h2 (inP (j, free))) {depth} (<=-transitive termDepth.maxTermDepthIsBigger (suc<=suc.conv rh))))
          \in transportInv
              (__ (\lam j => evaluate (S1, a1) (d j)) = S2.funcs f (\lam j => evaluate (S2, a2) (d j)))
              (h1 f)
              (pmap (S2.funcs f) p)

      \func substitutionLemma-> {L : Language} {I : Interpretation 0}
                                {n : Nat} {ts : Array (Term 0) n} {phi : Formula n}
                                (h : I ⊧ subst (ts !! __) phi):
        Interpretation.subst I (ts !! __) ⊧ phi \elim phi, h
        | equal x y, p => {?}
        | atomic r d, h => {?}
        | impH x phi, h => {?}
        | notH phi, h => {?}
        | forallH phi, h => {?}
    }

  \func logicalEquivalent \alias \infix 2 ≡ {L : Language} {n : Nat} (x y : Formula n) : \Prop =>
    \Sigma (x ⊫f y) (y ⊫f x)

  \func example : (NatStructure, nil) ⊧ {MonoidLang} forallH (forallH (equal
      (apply plus ((var 0) :: (var 1) :: nil))
      (apply plus ((var 1) :: (var 0) :: nil))
  )) => \lam x y => +-comm
    \where {
      \func MonoidLang : Language \cowith
        | Relations => Empty
        | relationsArity => absurd
        | Functions => MonoidFunctions
        | functionArity f => \case f \with {
          | plus => 2
        }

      \data MonoidFunctions | plus

      \func NatStructure : Structure MonoidLang \cowith
        | Universe => Nat
        | rel r => absurd r
        | funcs f args => \case \elim f, args \with {
          | plus, :: x (:: y nil) => x Nat.+ y
        }
    }
}