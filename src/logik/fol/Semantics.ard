\import Arith.Nat
\import Function
\import Function.Meta
\import Logic
\import LogicUtil
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import lambda.GeneralContext
\import logik.fol.FOL
\import logik.fol.Substitution
\import sets.Elements
\open NatSemiring (+-comm)
\open Term (FreeVar, termDepth)
\open Semantics (Structure, ⊧)
\open Semantics.Interpretation (subOne)

\module Semantics \where {
  \record Structure (L : Language)
    | Universe : \Set
    | rel : \Pi (r : Relations) (args : Array Universe (relationsArity r)) -> \Prop
    | funcs : \Pi (f : Functions) (args : Array Universe (functionArity f)) -> Universe

  \func Interpretation {L : Language} (c : TermContext) => \Sigma (S : Structure L) (variable c -> S.Universe)
    \where {
      -- TODO: SUbstOperations for Interpretation but in reverse??
      \func subst {L : Language} {c c' : TermContext} (I : Interpretation c) (s : TermSubst c' c) : Interpretation c' =>
        (I.1, \lam f => evaluate I (s f))

      \func subOne {L : Language} {c : TermContext} (I : Interpretation c) (with : Universe {I.1}) : Interpretation (c ∕ ()) =>
        (I.1, \lam f => \case \elim f \with {
          | Z p => with
          | S l => I.2 l
        })

      \func subOneRename {L : Language} {c : TermContext} {I : Interpretation c}
                         {x : Universe {I.1}} (t : Term c)
        : evaluate (subOne I x) (FOLTermSub.rename S t) = evaluate I t \elim t
        | var f => idp
        | apply f d => pmap (funcs {I.1} f) (ext $ ext $ (\lam j => subOneRename (d j)))
    }

  \func evaluate {L : Language} {c : TermContext} (I : Interpretation c) (t : Term c) : Universe {I.1} \elim t
    | var i => I.2 i
    | apply f d => funcs {I.1} f (\lam j => evaluate I (d j))
\where {
  \func evalSubst {L : Language} {c c' : TermContext} {I : Interpretation c'} (t : Term c)
                  {s s' : TermSubst c c'} (h : \Pi {f : variable c} (Term.FreeVar t f) -> evaluate I (s f) = evaluate I (s' f))
    : evaluate I (FOLTermSub.subst s t) = evaluate I (FOLTermSub.subst s' t)
  \elim t
    | var f => h idp
    | apply f d => pmap (Semantics.funcs {I.1} f)
      $ ext $ ext $ (\lam j => evalSubst (d j) (\lam {f1} f2 => h {f1} (inP (j, f2))))
}

  \func models \alias \infix 4 ⊧ {L : Language} {c : TermContext} (I : Interpretation c) (f : Formula c) : \Prop \elim f
    | equal x y => evaluate I x = evaluate I y
    | atomic r d => rel {I.1} r (\lam j => evaluate I (d j))
    | impH x y => (I ⊧ x) -> (I ⊧ y)
    | notH f => Not (I ⊧ f)
    | forallH f => \Pi (x : Universe {I.1}) -> subOne I x ⊧ f

  \func notModels \alias \infix 4 ⊭ {L : Language} {c : TermContext} (I : Interpretation c) (f : Formula c) : \Prop =>
    Not (I ⊧ f)

  \func modelImplies \alias \infix 6 ⊫f {L : Language} {c : TermContext} (x y : Formula c) : \Prop =>
    \Pi (I : Interpretation c) (I ⊧ x) -> I ⊧ y

  \func substitutionLemma {L : Language} {c : TermContext}
                          (phi : Formula c) (s : TermSubst c ∅)
                          (I : Interpretation ∅) :
    (I ⊧ FormulaSubst.subst s phi) <-> (Interpretation.subst I s ⊧ phi) =>
    (substitutionLemma->, substitutionLemma<-)

    \where {
      \func termCoincidenceLemma {L : Language} {c : TermContext} {U : \Set}
                                 {S1 S2 : Structure L U}
                                 {a1 a2 : variable c -> U}
                                 {t : Term c}
                                 (h1 : \Pi (f : L.Functions) -> S1.funcs f = S2.funcs f)
                                 (h2 : \Pi {i : variable c} (free : FreeVar t i) -> a1 i = a2 i)
        -- easy termination check
                                 {depth : Nat} (rh : termDepth t <= depth)
        : evaluate (S1, a1) t = evaluate (S2, a2) t
      \elim t, depth
        | var f, depth => h2 idp
        | apply f d, 0 => absurd (rh NatSemiring.zero<suc)
        | apply f d, suc depth =>
          \let p : (\lam j => evaluate (S1, a1) (d j)) = {Array U (functionArity f)} (\lam j => evaluate (S2, a2) (d j))
          => ext (ext (\lam j => termCoincidenceLemma h1 (\lam {i} free => h2 (inP (j, free))) {depth} (<=-transitive termDepth.maxTermDepthIsBigger (suc<=suc.conv rh))))
          \in transportInv
              (__ (\lam j => evaluate (S1, a1) (d j)) = S2.funcs f (\lam j => evaluate (S2, a2) (d j)))
              (h1 f)
              (pmap (S2.funcs f) p)

      \func coincidenceLemma {L : Language} {c : TermContext} {U : \Set}
                             {S1 S2 : Structure L U}
                             {a1 a2 : variable c -> U}
                             (f : Formula c) (m : (S1, a1) ⊧ f)
                             (h1 : \Pi (f : L.Functions) -> S1.funcs f = S2.funcs f)
                             (h2 : \Pi (r : L.Relations) -> S1.rel r = S2.rel r)
                             (h3 : \Pi {i : variable c} (free : Formula.FreeVar f i) -> a1 i = a2 i)
        : (S2, a2) ⊧ f
      \elim f
        | equal x y =>
          \let
            | xc => termCoincidenceLemma h1 (\lam free => h3 (byLeft free)) <=-refl
            | yc => termCoincidenceLemma h1 (\lam free => h3 (byRight free)) <=-refl
          \in inv xc *> m *> yc
        | atomic r d =>
          \let
            | d1 => \new Array S1.Universe (relationsArity r) (\lam j => evaluate (S1, a1) (d j))
            | d2 => \new Array S2.Universe (relationsArity r) (\lam j => evaluate (S2, a2) (d j))
            | d2=d1 : d2 = {Array U (relationsArity r)} d1 =>
              ext (ext (\lam (j : Fin (relationsArity r)) => inv (termCoincidenceLemma h1 (\lam free => h3 (inP (j, free))) <=-refl)))
            | r= : S2.rel r d2 = S1.rel r d1 => rewrite (h2 r) (pmap (S2.rel r) d2=d1)
          \in transportInv id r= m
        | impH x f => \lam m1 =>
            \let
              | fx => coincidenceLemma x m1 (invPi h1) (invPi h2) (\lam free => inv (h3 (byLeft free)))
              | fc => coincidenceLemma f (m fx) h1 h2 (\lam free => h3 (byRight free))
            \in fc
        | notH f => \lam m1 =>
            \let
              | fc => coincidenceLemma f m1 (invPi h1) (invPi h2) (\lam {i} free => inv (h3 free))
            \in m fc
        | forallH f => \lam x =>
            coincidenceLemma {L} {_} {U} {S1} {S2}
                {(subOne (S1, a1) x).2}
                {(subOne (S2, a2) x).2}
                f
                (m x)
                h1
                h2
                (\lam {i} free => \case \elim i, free \with {
                  | Z p, free => idp
                  | S l, free => h3 free
                })

      \func termSubstitution {L : Language} {c c' : TermContext} {I : Interpretation c'}
                             {s : TermSubst c c'} (x : Term c)
        : evaluate (Interpretation.subst I s) x = evaluate I (FOLTermSub.subst s x)
      \elim x
        | var f => idp
        | apply f d => pmap (funcs {I.1} f) (ext (ext (\lam j => termSubstitution (d j))))

      \func substitutionLemma-> {L : Language} {c c' : TermContext} {I : Interpretation c'}
                                {s : TermSubst c c'} {phi : Formula c}
                                (h : I ⊧ FormulaSubst.subst s phi) :
        Interpretation.subst I s ⊧ phi \elim phi, h
        | equal x y, p => termSubstitution x *> p *> inv (termSubstitution y)
        | atomic r d, h => transport (rel {I.1} r) (ext $ ext $ (\lam j => inv (termSubstitution (d j)))) h
        | impH x phi, h => \lam m => substitutionLemma-> (h (substitutionLemma<- m))
        | notH phi, h => \lam m => h (substitutionLemma<- m)
        | forallH phi, h => \lam x =>
            \let
              | psi => FormulaSubst.subst (FOLTermSub.extends s) phi
              | h' : subOne I x ⊧ psi => h x
              | h'' : Interpretation.subst (subOne I x) (FOLTermSub.extends s) ⊧ phi => substitutionLemma-> h'
              | goal : subOne (Interpretation.subst I s) x ⊧ phi => coincidenceLemma
                  phi
                  h''
                  (\lam f => idp)
                  (\lam r => idp)
                  (\lam {i} free => \case \elim i \with {
                    | Z _ => idp
                    | S l => Interpretation.subOneRename (s l)
                  })
            \in goal

      \func substitutionLemma<- {L : Language} {c c' : TermContext} {I : Interpretation c'}
                                {s : TermSubst c c'} {phi : Formula c}
                                (h : Interpretation.subst I s ⊧ phi)
        : I ⊧ FormulaSubst.subst s phi  \elim phi, h
        | equal x y, p => inv (termSubstitution x) *> p *> termSubstitution y
        | atomic r d, h => transport
            (rel {I.1} r)
            (ext $ ext $ (\lam j => termSubstitution (d j)))
            h
        | impH x phi, h => \lam m => substitutionLemma<- (h (substitutionLemma-> m))
        | notH phi, h => \lam m => h (substitutionLemma-> m)
        | forallH phi, h => \lam x =>
            \let
              | psi => FormulaSubst.subst (FOLTermSub.extends s) phi
              | h' : subOne (Interpretation.subst I s) x ⊧ phi => h x
              | h'' : Interpretation.subst (subOne I x) (FOLTermSub.extends s) ⊧ phi => coincidenceLemma
                  phi
                  h'
                  (\lam f => idp)
                  (\lam r => idp)
                  (\lam {i} free => \case \elim i \with {
                    | Z p => idp
                    | S l => inv (Interpretation.subOneRename (s l))
                  })
              | goal : subOne I x ⊧ psi => substitutionLemma<- {L} {_} {_} {subOne I x} h''
            \in goal
    }

  \func logicalEquivalent \alias \infix 2 ≡ {L : Language} {c : TermContext} (x y : Formula c) : \Prop =>
    \Sigma (x ⊫f y) (y ⊫f x)

  \func example : (NatStructure, \case __) ⊧ {MonoidLang} {∅} forallH (forallH (equal
      (apply plus (var #0 :: var #1 :: nil))
      (apply plus (var #1 :: var #0 :: nil))
  )) => \lam x y => +-comm
    \where {
      \func MonoidLang : Language \cowith
        | Relations => Empty
        | relationsArity => absurd
        | Functions => MonoidFunctions
        | functionArity f => \case f \with {
          | plus => 2
        }

      \data MonoidFunctions | plus

      \func NatStructure : Structure MonoidLang \cowith
        | Universe => Nat
        | rel r => absurd r
        | funcs f args => \case \elim f, args \with {
          | plus, :: x (:: y nil) => x Nat.+ y
        }
    }
}

\record SystemModel (L : Language) (S : System)
  | structure : Structure L
  | modelsAll : \Pi (f : Elements S) -> (structure, \case __) ⊧ f.1
