\import Arith.Nat
\import Data.Maybe
\import Function.Meta
\import Logic
\import Meta
\import Order.LinearOrder
\import Paths
\import Paths.Meta
\import identity.NatIdentity
\import lambda.GeneralContext
\import logik.fol.FOL
\import logik.fol.Incompleteness
\import logik.fol.Semantics
\import logik.fol.Substitution
\import sets.FromArray
\import util.CantorPair
\import util.Maybe (maybeMap, maybeMap2)
\open Semantics (Structure)
\open NatSemiring (<)

\func LNN : CodeableLanguage \cowith
  | Relations => LNN'.Relations
  | relationsArity => LNN'.relationsArity
  | Functions => LNN'.Functions
  | functionArity => LNN'.functionArity
  | encode => encodeFormula
  | natToTerm => natToTerm
  | decode => decodeFormula __ __ 100000
  \where {
    -- seperate Lang definition, bc otherwise encode cannot be implemented (need Lang to already be defined)

    \func LNN' : Language \cowith
      | Relations => LNN_Relations
      | relationsArity => \case __ \with {
        | LNN.Less => 2
      }
      | Functions => LNN_Functions
      | functionArity => \case __ \with {
        | LNN.Plus => 2
        | LNN.Times => 2
        | LNN.Succ => 1
        | LNN.Zero => 0
      }

    \data LNN_Relations | Less

    \data LNN_Functions | Plus | Times | Succ | Zero

    \func encodeFormula {c : TermContext} (f : Formula {LNN'} c) : Nat
    \elim f
      | equal x y => cPair 0 (cPair (encodeTerm x) (encodeTerm y))
      | atomic Less d => cPair 1 (encodeTerms d)
      | impH x f => cPair 2 (cPair (encodeFormula x) (encodeFormula f))
      | notH f => cPair 3 (encodeFormula f)
      | forallH f => cPair 4 (encodeFormula f)

    \func decodeFormula (encoded : Nat) (c : TermContext) (fuel : Nat) : Maybe (Formula {LNN'} c) \elim fuel
      | 0 => nothing
      | suc fuel => \let (type, value) => cPair.unPair encoded  \in decodeFormulaCase type value c fuel
      \where {
        \func decodeFormulaCase (type value : Nat) (c : TermContext) (fuel : Nat) : Maybe (Formula {LNN'} c) \elim type
          | 0 => \let (x, y) => cPair.unPair value \in (decodeTerm x c fuel, decodeTerm y c fuel) maybeMap2 (\lam t t1 => equal t t1)
          | 1 => decodeTerms value c 2 fuel maybeMap {Array (Term {LNN'} c) 2} (\lam d => atomic Less d)
          | 2 => \let (x, y) => cPair.unPair value \in (decodeFormula x c fuel, decodeFormula y c fuel) maybeMap2 (\lam f f1 => f impH f1)
          | 3 => decodeFormula value c fuel maybeMap (\lam f => notH f)
          | 4 => decodeFormula value (c ∕ ()) fuel maybeMap (\lam f => forallH f)
          | _ => nothing
      }

    \func encodeTerm {c : TermContext} (t : Term {LNN'} c) : Nat
    \elim t
      | var f => cPair 0 (∋.toIndexFin f)
      | apply Plus d => cPair 1 (encodeTerms d)
      | apply Times d => cPair 2 (encodeTerms d)
      | apply Succ d => cPair 3 (encodeTerms d)
      | apply Zero d => cPair 4 (encodeTerms d)

    \func decodeTerm (encoded : Nat) (c : TermContext) (fuel : Nat) : Maybe (Term {LNN'} c) \elim fuel
      | 0 => nothing
      | suc fuel => \let (type, value) => cPair.unPair encoded  \in decodeTermCase type value c fuel
      \where {
        \func decodeTermCase (type value : Nat) (c : TermContext) (fuel : Nat) : Maybe (Term {LNN'} c) \elim type
          | 0 => \case NatSemiring.trichotomy value (Context.length c) \with {
            | less n2<ctx => just (var (∋.fromIndexFin (toFin {value} n2<ctx)))
            | equals n2=ctx => nothing
            | greater n2>ctx => nothing
          }
          | 1 => decodeTerms value c 2 fuel maybeMap {Array (Term {LNN'} c) 2} (\lam d => apply Plus d)
          | 2 => decodeTerms value c 2 fuel maybeMap {Array (Term {LNN'} c) 2} (\lam d => apply Times d)
          | 3 => decodeTerms value c 1 fuel maybeMap {Array (Term {LNN'} c) 1} (\lam d => apply Succ d)
          | 4 => decodeTerms value c 0 fuel maybeMap {Array (Term {LNN'} c) 0} (\lam d => apply Zero d)
          | _ => nothing
      }

    \func encodeTerms {c : TermContext} (ts : Array (Term {LNN'} c)) : Nat
    \elim ts
      | nil => 0
      | :: a arr => cPair (encodeTerm a) (encodeTerms arr)

    \func decodeTerms (encoded : Nat) (c : TermContext) (l : Nat) (fuel : Nat) : Maybe $ Array (Term {LNN'} c) l
    \elim l
      | 0 => \case encoded \with {
        | 0 => just nil
        | suc n => nothing
      }
      | suc l =>
        \let (n1, n2) => cPair.unPair encoded
        \in \case decodeTerm n1 c fuel, decodeTerms n2 c l fuel \with {
          | nothing, _ => nothing
          | _, nothing => nothing
          | just a, just arr => just (a :: arr)
        }

    \func requiredFuelTerm {c : TermContext} (f : Term {LNN'} c) : Nat \elim f
      | var v => 1
      | apply f d => 2

    \func decodeEncodeTerm {c : TermContext} {t : Term {LNN'} c} : decodeTerm (encodeTerm t) c (requiredFuelTerm t) = just t
    \elim t
      | var v =>
        \let
          | h => variable.fromToIndexFin v
          | p : toFin (fin_< (Lookup.toIndexFin v)) = {Fin (Context.length c)} Lookup.toIndexFin v =>
            {?}
        \in run {
          rewrite (CantorPairing.unPaircPair (0, ∋.toIndexFin v)),
          unfold_let,
          rewrite (LinearOrder.trichotomy<_reduce (fin_< _)),
          pmap just,
          pmap (var {LNN'}),
          pmap ∋.fromIndexFin p *> h
        }
      | apply Plus d => run {
        rewrite (CantorPairing.unPaircPair (1, encodeTerms d)),
        unfold_let,
        {?}
      }
      | apply Times d => {?}
      | apply Succ d => {?}
      | apply Zero d => {?}

    \func requiredFuel {c : TermContext} (f : Formula {LNN'} c) : Nat \elim f
      | equal x y => 2
      | atomic r d => 0
      | x impH f => 0
      | notH f => 0
      | forallH f => 0

    \func decodeEncode {c : TermContext} {f : Formula {LNN'} c} : decodeFormula (encodeFormula f) c (requiredFuel f) = just f
    \elim f
      | equal x y => run {
        rewrite (CantorPairing.unPaircPair (0, cPair (encodeTerm x) (encodeTerm y))),
        unfold_let,
        {?}
      }

      | atomic r d => {?}
      | x impH f => {?}
      | notH f => {?}
      | forallH f => {?}

    \func natToTerm (encoded : Nat) : Term {LNN'} ∅
      | 0 => apply Zero nil
      | suc n => apply Succ (natToTerm n :: nil)
  }

\func NN : System {LNN} => \let axioms : Array (Formula {LNN} ∅) 9 =>
  -- ∀x0. ¬ Sx0 = 0
  forallH (notH (equal (apply LNN.Succ (var {LNN} #0 :: nil)) (apply LNN.Zero nil))) ::
  -- ∀x1. ∀x0. (Sx1 = Sx0 ⇒ x1 = x0)
  forallH (forallH (impH
      (equal (apply LNN.Succ (var #1 :: nil)) (apply LNN.Succ (var #0 :: nil)))
      (equal (var #1) (var #0))
  )) ::
  -- ∀x0. x0 + 0 = x0
  forallH (equal (apply LNN.Plus (var #0 :: apply LNN.Zero nil :: nil)) (var #0)) ::
  -- ∀x1. ∀x0. x1 + Sx0 = S(x1 + x0)
  {?} ::
  -- ∀x0. x0 × 0 = 0
  {?} ::
  -- ∀x1. ∀x0. x1 × Sx0 = (x1 × x0) + x0
  {?} ::
  -- ∀x0. ¬x0 < 0
  {?} ::
  -- ∀x1. ∀x0. (x1 < Sx0 ⇒ (x1 = x0 ∨ x1 < x0))
  {?} ::
  -- ∀x1. ∀x0. (x1 < x0 ∨ x1 = x0 ∨ x0 < x1)
  {?} ::
  nil \in fromArray axioms

\func NNModel : SystemModel LNN NN \cowith
  | structure => \new Structure {
    | Universe => Nat
    | rel => \case \elim __ \with {
      | LNN.Less => \case __ \with {
        | :: x (:: y nil) => x < y
      }
    }
    | funcs => \case \elim __ \with {
      | LNN.Plus => \case __ \with {
        | :: x (:: y nil) => x Nat.+ y
      }
      | LNN.Times => \case __ \with {
        | :: x (:: y nil) => x Nat.* y
      }
      | LNN.Succ => \case __ \with {
        | :: x nil => suc x
      }
      | LNN.Zero => \case __ \with {
        | nil => 0
      }
    }
  }
  | modelsAll => \case \elim __ \with {
    | (_, inP (0, idp)) => \lam x m => suc/=0 m
    | (_, inP (1, idp)) => \lam x x1 m => unsuc m
    | (_, inP (2, idp)) => \lam x => idp
    | (_, inP (3, idp)) => {?}
    | (_, inP (4, idp)) => {?}
    | (_, inP (5, idp)) => {?}
    | (_, inP (6, idp)) => {?}
    | (_, inP (7 ,idp)) => {?}
    | (_, inP (8 ,idp)) => {?}
  }
