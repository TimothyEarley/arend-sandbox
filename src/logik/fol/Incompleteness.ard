\import Data.Maybe
\import Data.Or
\import Function.Meta ($)
\import Paths
\import Paths.Meta
\import lambda.GeneralContext
\import logik.fol.FOL
\import logik.fol.LNN
\import logik.fol.Lifting
\import logik.fol.SequentCalculus
\import logik.fol.Substitution
\import sets.DecidableSet
\import sets.subset
\import util.ArrayUtils
\open SequentCalulus (⊢)
\open CodeableLanguage (⊻⊼)

\class CodeableLanguage \extends Language {
  | encode \alias ⊼ : \Pi {c : TermContext} (Formula {\this} c) -> Nat
  | natToTerm \alias ⊻ : Nat -> Term ∅
  | decode : \Pi (n : Nat) (c : TermContext) -> Maybe (Formula c)

  \func encodeToTerm \alias ⊻⊼ {c : TermContext} (f : Formula c) : Term ∅ => ⊻ (⊼ f)
}

\class AllowsRepresentations (C : CodeableLanguage) (T : System)
  | functionRepresentation {r : Nat} (f : Array Nat r -> Nat) :
  \Sigma (phi : Formula (∅ Context.∕∕ ArrayUtils.arrayOf' () {suc r}))
         (\Pi (a : Array Nat r) ->
             T ⊢ FormulaSubst.subst {C}
                     (\case \elim __ \with {
                       | Z p => ⊻ (f a)
                       | S l => ⊻ (a (rewriteF Context.length-∕∕ $ ∋.toIndexFin l))
                     })
                     phi)

\func Inconsistent {L : Language} (T : System) => \Pi (f : Formula ∅) -> T ⊢ f

\func fixedPoint (C : CodeableLanguage) (T : System)
                 (R : AllowsRepresentations C T)
                 (psi : Formula (∅ ∕ ())) : \Sigma (phi : Formula ∅) (T ⊢ phi <->H FormulaSubst.sub psi (natToTerm (⊼ phi))) =>
  \let
    -- F codes for (x : Term, y : Nat) -> x[0->y]
    | F : (Array Nat 2) -> Nat => \case __ \with {
      | :: n (:: m nil) => \case decode n (∅ ∕ ()) \with {
        | nothing => 0
        | just xi => ⊼ (FormulaSubst.sub xi (⊻ m))
      }
    }
    | (alpha, fRepH) => R.functionRepresentation F
    | beta : Formula (∅ ∕ ()) => forallH ({?} impH FormulaLifting.lift psi)
    | phi : Formula ∅ => forallH ({?} impH {?})
    | betabeta : phi = FormulaSubst.sub beta (⊻⊼ beta) => {?}
    | Fbeta : F (⊼ beta :: ⊼ beta :: nil) = ⊼ phi => {?}

    | h' : R.T ⊢ FormulaSubst.subst (\lam {A : \Sigma} (p0 : ∅ ∕ () ∕ () ∕ () ∋ A) => \case p0 \with {
      | Z _ => ⊻ (F (⊼ beta :: ⊼ beta :: nil))
      | S l => ⊻ ((⊼ beta :: ⊼ beta :: nil) (∋.toIndexFin l))
    }) alpha => fRepH (⊼ beta :: ⊼ beta :: nil)
    | h : T ⊢ FormulaSubst.sub3 alpha (⊻⊼ phi) (⊻⊼ beta) (⊻⊼ beta) =>
      transport (T ⊢ FormulaSubst.subst __ alpha)
                                       {\lam {A : \Sigma} (p0 : ∅ ∕ () ∕ () ∕ () ∋ A) => \case p0 \return Term ∅ \with {
                                         | Z _ => ⊻ (F (⊼ beta :: ⊼ beta :: nil))
                                         | S l => ⊻ ((⊼ beta :: ⊼ beta :: nil) (∋.toIndexFin l))
                                       }}
                                       {FormulaSubst.sub3.extends3 _ _ _}
                                       (ext (\case \elim __ \with {
                                         | Z p => pmap ⊻ Fbeta
                                         | S (Z _) => idp
                                         | S (S (Z _)) => idp
                                         | S (S (S ()))
                                       }))
                                       h'
  \in (phi,
       {?})


-- according to lemma 37.2 of https://builds.openlogicproject.org/open-logic-complete.pdf
--\func diag {C : CodeableLanguage} {T : System}
--           {R : AllowsRepresentations C T}
--           (psi : Formula (∅ ∕ ())) : Formula ∅
--  => FormulaSubst.sub psi (⊻ (⊼ psi))
--
--\func fixedPoint2 (C : CodeableLanguage) (T : System)
--                 (R : AllowsRepresentations C T)
--                 (psi : Formula (∅ ∕ ())) : \Sigma (phi : Formula ∅) (T ⊢ phi <->H FormulaSubst.sub psi (natToTerm (⊼ phi))) =>
--  \let
--    | diagN : (Array Nat 1) -> Nat => \case __ \with {
--      | :: n nil => \case decode n (∅ ∕ ()) \with {
--        | nothing => 0
--        | just xi => ⊼ (FormulaSubst.sub xi (⊻⊼ xi))
--      }
--    }
--    | (diagF : Formula (∅ ∕ () ∕ ()), diagProof) => R.functionRepresentation diagN
--    | alpha : Formula (∅ ∕ ()) => existsH ({?} andH {?}) -- diagF(x, y) and psi(y)
--
--
--  \in {?}

\func Incompleteness (T : System {LNN}) {DT : DecElementEnsemble _ T}
                     (hasNN : NN ⊆ T)
                     (represents : AllowsRepresentations LNN T)
  : \Sigma  (f : Formula {LNN} ∅)
            (Or (T ⊢ {LNN} f) (T ⊢ {LNN} notH f) -> Inconsistent {LNN} T) =>
  ({?},
   \lam o f => {?})