\import Data.Array
\import Data.Maybe
\import Data.Or
\import Function.Meta ($)
\import Paths.Meta
\import lambda.GeneralContext
\import logik.fol.FOL
\import logik.fol.LNN
\import logik.fol.SequentCalculus
\import logik.fol.Substitution
\import sets.DecidableSet
\import sets.subset
\open SequentCalulus (⊢)
\open CodeableLanguage (⊻⊼)

\class CodeableLanguage \extends Language {
  | encode \alias ⊼ : \Pi {c : TermContext} (Formula {\this} c) -> Nat
  | natToTerm \alias ⊻ : Nat -> Term ∅
  | decode : \Pi (n : Nat) (c : TermContext) -> Maybe (Formula c)

  \func encodeToTerm \alias ⊻⊼ {c : TermContext} (f : Formula c) : Term ∅ => ⊻ (⊼ f)
}


\class AllowsRepresentations (C : CodeableLanguage) (T : System)
  | functionRepresentation {r : Nat} (f : Array Nat r -> Nat) :
    \Sigma (phi : Formula (suc r)) (\Pi (a : Array Nat r) -> T ⊢ subN' phi (natToTerm (f a) :: map natToTerm a))

\func Inconsistent {L : Language} (T : System) => \Pi (f : Formula ∅) -> T ⊢ f

\func fixedPoint (C : CodeableLanguage) (T : System)
                 (R : AllowsRepresentations C T)
                 (psi : Formula 1) : \Sigma (phi : Formula 0) (T ⊢ phi <->H sub psi (natToTerm (encode phi)))
  => \let
     | F : (Array Nat 2) -> Nat => \case __ \with {
       | :: n (:: m nil) => \case decode n 1 \with {
         | nothing => 0
         | just xi => encode (sub xi (natToTerm m))
       }
     }
     | (alpha, fRepH) => R.functionRepresentation F
     | beta : Formula 1 => forallH ({?} impH {?})
     | phi : Formula 0 => forallH ({?} impH {?})
     | betabeta : phi = sub beta (⊻⊼ beta) => {?}
     | Fbeta : F (⊼ beta :: ⊼ beta :: nil) = ⊼ phi => {?}
     | h' => rewriteF Fbeta $ fRepH (⊼ beta :: ⊼ beta :: nil)
     | h : T ⊢ subN' alpha (⊻⊼ phi :: ⊻⊼ beta :: ⊻⊼ beta :: nil) => {?} -- should just be h'
     \in (phi,
          ⊢.intro-<->H
              (SequentCalulus.impIntro {?})
              {?})

\func Incompleteness (T : System {LNN}) {DT : DecElementEnsemble _ T}
                     (hasNN : NN ⊆ T)
                     (represents : AllowsRepresentations LNN T)
  : \Sigma  (f : Formula {LNN} 0)
            (Or (T ⊢ {LNN} f) (T ⊢ {LNN} notH f) -> Inconsistent {LNN} T) =>
  ({?},
   \lam o f => {?})