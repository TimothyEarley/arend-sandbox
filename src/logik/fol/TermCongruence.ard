\import Logic
\import Relation.Equivalence
\import Util
\import logik.fol.FOL
\import logik.fol.SequentCalculus
\import logik.fol.Substitution
\import sets.MySet
\open SequentCalulus (⊢)

\class TermCongruence {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)} \extends Equivalence
  | A => Term c
  | fCong (f : Functions)
          (d : Array (Term c) (functionArity f))
          (d' : Array (Term c) (functionArity f))
          (d~d' : \Pi (i : Fin (functionArity f)) -> d i ~ d' i) : apply f d ~ apply f d'
  | relCong  (r : Relations)
             (d : Array (Term c) (relationsArity r))
             (d' : Array (Term c) (relationsArity r))
             (d~d' : \Pi (i : Fin (relationsArity r)) -> d i ~ d' i)
             (h : axioms ⊢ atomic r d) : TruncP (axioms ⊢ atomic r d') -- TruncP might be wrong

\func T~ {L : Language} {c : TermContext} (axioms : Ensemble (Formula c)) : TermCongruence \cowith
  | L => L
  | c => c
  | axioms => axioms
  | ~ x y => TruncP (axioms ⊢ equal x y)
  | ~-reflexive => inP (SequentCalulus.E-Refl idp)
  | ~-symmetric {x} {y} (inP h) => inP (⊢.E-Symm h)
  | ~-transitive {x} {y} {z} (inP h) (inP h') => inP (⊢.E-Trans h h')
  | fCong f d d' d~d' => \case truncMap d~d' \with {
    | inP f_d~d' => inP (⊢.EqualApply f_d~d')
  }
  | relCong r d d' d~d' h => \case truncMap d~d' \with {
    | inP r_d~d' => inP (⊢.EqualRel r_d~d' h)
  }
