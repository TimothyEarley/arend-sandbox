\import Data.Array
\import Function.Meta ($)
\import Logic
\import Meta
\import Misc
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Util
\import logik.fol.FOL
\import logik.fol.FormulaDec
\import logik.fol.Semantics
\import sets.Add
\import sets.DecidableSet
\import sets.finite.FiniteS
\import sets.MySet
\import sets.finite.Sized
\import sets.finite.paper
\import sets.remove
\import sets.subset
\import sets.union
\import util.ArrayUtils
\open Semantics (Interpretation, evaluate, ⊧)
\open Term (AnyFreeVar, FreeVar, lift, liftN, liftNL, lifts, liftsN)
\open Formula (Subst, extends, extendsN, sub, subN, subTerm, subTermLift, subTerms, subTermsAt, subst)
\open Interpretation (subOneRename)

\module SequentCalulus \where {


  -- TODO finite axioms

  \data SequentProof \alias \infix 6 ⊢ {L : Language} {n : Nat} (axioms : Ensemble (Formula n)) (toShow : Formula n)
  \elim toShow
    | toShow => Ass (toShow ∈ axioms)
    | toShow => PC (psi : Formula n) (add {Formula n} axioms psi ⊢ toShow) (add axioms (notH psi) ⊢ toShow)
    | toShow => Ctr (psi : Formula n)
                    (add axioms (notH toShow) ⊢ psi) (add axioms (notH toShow) ⊢ (notH psi))

    -- TODO ...

    | equal x y => E-Refl (x = y)
    | toShow => E-Subst (t t' : Term n) (equal t t' ∈ axioms)
                        (phi : Formula (suc n))
                        (axioms ⊢ sub phi t)
                        (p : toShow = sub phi t')
    \where {
      \func Contr' {L : Language} {n : Nat} {axioms :  Ensemble (Formula n)} {toShow : Formula n}
                   (phi : Formula n) (h : axioms ⊢ phi) (h' : axioms ⊢ notH phi) : axioms ⊢ toShow =>
        Ctr phi (weaken h (byLeft __)) (weaken h' (byLeft __))

      \func MP {L : Language} {n : Nat} {axioms :  Ensemble (Formula n)} {toShow : Formula n}
               (phi : Formula n) (h : axioms ⊢ phi) (h' : add axioms phi ⊢ toShow)
        : axioms ⊢ toShow => PC phi
          h'
          (Contr' phi (weaken h (byLeft __)) (Ass (byRight idp)))

      \func E-Subst' {L : Language} {n : Nat} {axioms : Ensemble (Formula n)}
                     (t t' : Term n) (te : axioms ⊢ equal t t') (phi : Formula (suc n))
                     (h : axioms ⊢ sub phi t)
                     {toShow : Formula n} (p : toShow = sub phi t') : axioms ⊢ toShow =>
        MP (equal t t') te (E-Subst t t' (byRight idp) phi (weaken h (byLeft __)) p)

      \func E-Symm {L : Language} {n : Nat} {axioms : Ensemble (Formula n)}
                   {x y : Term n}
                   (h : axioms ⊢ equal x y) : axioms ⊢ equal y x =>
        E-Subst'
            x y h
            (equal (var 0) (lift x))
            (unfold (sub) $ rewrite (subTermLift _ (\lam f => idp)) (E-Refl idp))
            (unfold (sub) $ rewrite (subTermLift _ (\lam f => idp)) idp)

      \func E-Trans {L : Language} {n : Nat} {axioms : Ensemble (Formula n)}
                    {x y z : Term n}
                    (h : axioms ⊢ equal x y) (h' : axioms ⊢ equal y z) : axioms ⊢ equal x z =>
        \let h'' :  add axioms (equal y z) ⊢ equal x y => weaken h (byLeft __)
        \in E-Subst' y z h'
            (equal (lift x) (var 0))
            (unfold (sub) $ rewrite (subTermLift _ (\lam f => idp)) h)
            (unfold (sub) $ rewrite (subTermLift _ (\lam f => idp)) idp)

      -- TruncP because thats where we use it

      \func E-SubstN {L : Language} {baseNum numOfAdded : Nat}
                     {toShow : Formula baseNum}
                     (axioms : Ensemble (Formula baseNum))
                     (d d' : Array (Term baseNum) numOfAdded)
                     (f : Formula (baseNum Nat.+ numOfAdded))
                     (hp : axioms ⊢ subN f d)
                     (dd' : DArray (\lam i => TruncP (axioms ⊢ equal (d i) (d' i))))
                     (tsp : subN f d' = toShow)
        : TruncP (axioms ⊢ toShow) \elim numOfAdded, d, d', dd'
        | 0, nil, nil, nil => rewriteI tsp (inP hp)
        | suc numOfAdded, :: t d, :: t' d', :: (inP t=t') dd' =>
          E-SubstN axioms d d'
              (sub f (liftN _ t'))
              (E-Subst' t t' t=t' {?} {?} {?})
              dd'
              ((inv subN.recurseSub) *> tsp)
    }

  \func weaken {L : Language} {n : Nat} {axioms axioms' : Ensemble (Formula n)} {toShow : Formula n}
               (h : axioms ⊢ toShow) (s : axioms ⊆ axioms') : axioms' ⊢ toShow \elim toShow, h
    | toShow, Ass e => Ass (s e)
    | toShow, PC psi h1 h2 => PC psi
        (weaken h1 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
        (weaken h2 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
    | toShow, Ctr psi h1 h2 => Ctr psi
        (weaken h1 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
        (weaken h2 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
    | equal x y, E-Refl p => E-Refl p
    | toShow, E-Subst t t' e phi h p => E-Subst t t' (s e) phi (weaken h s) p

  \func entails \alias \infix 6 ⊫e {L : Language} (from : Ensemble (Formula 0)) (to : Formula 0) =>
    \Pi (I : Interpretation 0) (h : \Pi {f : Formula 0} (f ∈ from) -> I ⊧ f) -> I ⊧ to

  -- TODO how should the classical requirement be handled?

  \func proofIsEntails
    {L : Language} {from : Ensemble (Formula 0)} {to : Formula 0}
    (decidable : \Pi (I : Interpretation 0) (f : Formula 0) -> Dec (I ⊧ f))
    (h : from ⊢ to) : from ⊫e to
  \elim to, h
    | to, Ass e => \lam I h => h e
    | to, PC psi h1 h2 => \lam I h =>
        \let dec : Dec (I ⊧ psi) => decidable I psi
        \in \case dec \with {
          | yes e => proofIsEntails decidable h1 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p e
          })
          | no n => proofIsEntails decidable h2 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p n
          })
        }
    | to, Ctr psi h1 h2 => \lam I h => \case decidable I to \with {
      | yes e => e
      | no n => \let
        | Ipsi => proofIsEntails decidable h1 I (\case __ \with {
          | byLeft a => h a
          | byRight p => rewriteI p n
        })
        | InotPsi => proofIsEntails decidable h2 I (\case __ \with {
          | byLeft a => h a
          | byRight p => rewriteI p n
        })
                \in absurd (InotPsi Ipsi)
    }
    | equal x y, E-Refl idp => \lam I h => idp
    | to, E-Subst t t' e phi h idp => \lam I h1 =>
        \let
          | p => h1 e
          | IphiT => proofIsEntails decidable h I h1
        \in subModel IphiT p

  \func subModel {L : Language} {I : Interpretation 0} {phi : Formula 1} {t t' : Term 0}
                 (h : I ⊧ sub phi t) (e : evaluate I t = evaluate I t')
    : I ⊧ sub phi t' => substModel phi (\lam {f : Fin 1} f1 => \case \elim f \with {
    | zero => e
  }) h
    \where {
      \func substModel {L : Language} {n m : Nat} {I : Interpretation m} (phi : Formula n)
                       {s s' : Subst n m} (freeSame : \Pi {f : Fin n} (Formula.FreeVar phi f) -> evaluate I (s f) = evaluate I (s' f))
                       (h : I ⊧ subst s phi)
        : I ⊧ subst s' phi
      \elim phi
        | equal x y => (evalSubst x (\lam fr => inv (freeSame (byLeft fr)))) *> h *> (evalSubst y (\lam fr => freeSame (byRight fr)))
        | atomic r d => transport (Semantics.rel {I.1} r)
            (ext (ext (\lam j => rewriteF (inv $ subTermsAt j, inv $ subTermsAt j) (evalSubst (d j) (\lam {k} free => freeSame $ inP (j, free))))))
            h
        | impH x phi => \lam mo => \let xs : I ⊧ subst s x => substModel x (\lam fr => inv (freeSame (byLeft fr))) mo
                                   \in substModel phi (\lam fr => freeSame (byRight fr)) (h xs)
        | notH phi => \lam mo => h (substModel phi (\lam fr => inv (freeSame fr)) mo)
        | forallH phi => \lam x => substModel
            phi
            {extends s}
            (\lam {k} free => \case \elim k, free \with {
              | 0, free => idp
              | suc k, free => \let fs => freeSame free \in unfold (extends) (subOneRename (s k) *> fs *> (inv (subOneRename (s' k))))
            })
            (h x)

      \func evalSubst {L : Language} {n m : Nat} {I : Interpretation m} (t : Term n)
                      {s s' : Subst n m} (h : \Pi {f : Fin n} (FreeVar t f) -> evaluate I (s f) = evaluate I (s' f))
        : evaluate I (subTerm s t) = evaluate I (subTerm s' t)
      \elim t
        | var f => h idp
        | apply f d => pmap (Semantics.funcs {I.1} f)
            (ext (ext (\lam j =>
                \let h' => (evalSubst (d j) (\lam {k} free => h $ inP (j, free)))
                \in rewriteF (inv $ subTermsAt j, inv $ subTermsAt j) h')))
    }

  -- TODO show that it is subset

  \func sequentProofUsesFiniteAxioms {L : DecLanguage} {axioms : DecElementEnsemble (Formula 0)} {f : Formula 0}
                                     (h : axioms ⊢ f) : \Sigma (reducedAxioms : DecSizedEnsemble (Formula 0)) (reducedAxioms.S ⊆ axioms) (reducedAxioms ⊢ f)
  \elim f, h
    | f, Ass e => (DecSizedEnsemble.fromSizedEnsemble $ SizedEnsemble.singleSized f, ⊆.singleSubset e, Ass idp)
    | equal x y, E-Refl p => (DecSizedEnsemble.fromSizedEnsemble $ SizedEnsemble.emptySized, ⊆.∅-is-⊆, E-Refl p)
    | f, PC psi h1 h2 =>
      \let
        | (ax1 : DecSizedEnsemble, sax1, pax1) => sequentProofUsesFiniteAxioms {_} {axioms.addElement psi} h1
        | (ax2 : DecSizedEnsemble, sax2, pax2) => sequentProofUsesFiniteAxioms {_} {axioms.addElement (notH psi)} h2
        -- we need to remove psi from ax1 (if it has it) unless it was already present in axioms
      \in \case axioms.decElement psi, ax1.decElement psi, axioms.decElement (notH psi), ax2.decElement (notH psi) \with {
        -- psi is already in axioms, we can cut the tree to that branch of PC
        | yes e, _, _, _ => (ax1, ⊆.trans sax1 (⊆.unionSubset ⊆.refl (⊆.singleSubset e)), pax1)
        -- same thing for notH psi
        | _, _, yes e, _ => (ax2, ⊆.trans sax2 (⊆.unionSubset ⊆.refl (⊆.singleSubset e)), pax2)
        -- psi and notH psi need to be removed
        | no n, yes psiIn, no n1, yes nPsiIn =>
          \let
            | ax1' : DecSizedEnsemble => ax1.removeSized psiIn
            | ax2' : DecSizedEnsemble => ax2.removeSized nPsiIn
            | axioms' => ax1'.unionSized ax2'
            | ax1sub : ax1.S ⊆ add axioms' psi => \lam {x} e => \case decideEq psi x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft (e, n2))
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH psi) => \lam {x} e => \case decideEq (notH psi) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byRight (e, n2))
            }
          \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) (⊆.removeAdd sax2),
               PC psi (weaken pax1 ax1sub) (weaken pax2 ax2sub)
          )

        -- only psi needs to be removed
        | no n, yes psiIn, no n1, no n2 =>
          \let
            | ax1' : DecSizedEnsemble => ax1.removeSized psiIn
            | axioms' => ax1'.unionSized ax2
            | sax2' : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n2) $ ⊆.removeAdd sax2
            | ax1sub : ax1.S ⊆ add axioms' psi => \lam {x} e => \case decideEq psi x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft (e, n2))
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH psi) => \lam {x} e => byLeft (byRight e)
          \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) sax2', PC psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))

        -- only notH psi needs to be removed
        | no n, no n1, no n2, yes nPsiIn =>
          \let
            | ax2' : DecSizedEnsemble => ax2.removeSized nPsiIn
            | axioms' => ax1.unionSized ax2'
            | sax1' : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax1
            | ax1sub : ax1.S ⊆ add axioms' psi => \lam {x} e => \case decideEq psi x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft e)
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH psi) => \lam {x} e => \case decideEq (notH psi) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byRight (e, n2))
            }
          \in (axioms', ⊆.unionSubset sax1' (⊆.removeAdd sax2),
               PC psi (weaken pax1 ax1sub) (weaken pax2 ax2sub)
          )
        -- we don't need to remove anything
        | no n, no n1, no n2, no n3 =>
          \let
            | ax1sub : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) (⊆.removeAdd sax1)
            | ax2sub : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n3) (⊆.removeAdd sax2)
          \in (ax1.unionSized ax2, ⊆.unionSubset ax1sub ax2sub, PC psi (weaken pax1 (byLeft $ byLeft __)) (weaken pax2 (byLeft $ byRight __)))
      }

    | f, Ctr psi h1 h2 =>
      \let
        | (ax1 : DecSizedEnsemble, sax1, pax1) => sequentProofUsesFiniteAxioms {_} {axioms.addElement (notH f)} h1
        | (ax2 : DecSizedEnsemble, sax2, pax2) => sequentProofUsesFiniteAxioms {_} {axioms.addElement (notH f)} h2
      \in \case axioms.decElement (notH f), ax1.decElement (notH f), ax2.decElement (notH f) \with {
        | yes e, _, _ => (ax1.unionSized ax2,
                          ⊆.unionSubset
                              (⊆.trans sax1 (⊆.unionSubset ⊆.refl (\lam {x} x=notH => transport (__ ∈ axioms.S) x=notH e)))
                              (⊆.trans sax2 (⊆.unionSubset ⊆.refl (\lam {x} x=notH => transport (__ ∈ axioms.S) x=notH e))),
                          Ctr psi (weaken pax1 (\lam z => byLeft (byLeft z))) (weaken pax2 (\lam z => byLeft (byRight z))))
        | no n, yes e, yes e1 => \let
          | ax1' : DecSizedEnsemble => ax1.removeSized e
          | ax2' : DecSizedEnsemble => ax2.removeSized e1
          | axioms' => ax1'.unionSized ax2'
          | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
            | yes e1 => byRight e1
            | no n2 => byLeft (byLeft (e, n2))
          }
          | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
            | yes e1 => byRight e1
            | no n2 => byLeft (byRight (e, n2))
          }
                                 \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) (⊆.removeAdd sax2),
                                      Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub)
          )
        | no n, yes e, no n1 => \let
          | ax1' : DecSizedEnsemble => ax1.removeSized e
          | axioms' => ax1'.unionSized ax2
          | sax2' : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax2
          | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
            | yes e1 => byRight e1
            | no n2 => byLeft (byLeft (e, n2))
          }
          | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam z => byLeft (byRight z)
                                \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) sax2',
                                     Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))
        | no n, no n1, yes e => \let
          | ax2' : DecSizedEnsemble => ax2.removeSized e
          | axioms' => ax1.unionSized ax2'
          | sax1' : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax1
          | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam z => byLeft (byLeft z)
          | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
            | yes e1 => byRight e1
            | no n2 => byLeft (byRight (e, n2))
          }
                                \in (axioms', ⊆.unionSubset sax1' (⊆.removeAdd sax2),
                                     Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))
        | no n, no n1, no n2 => \let
          | axioms' => ax1.unionSized ax2
          | sax1' : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax1
          | sax2' : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n2) $ ⊆.removeAdd sax2
          | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam z => byLeft (byLeft z)
          | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam z => byLeft (byRight z)
                                \in (axioms', ⊆.unionSubset sax1' sax2',
                                     Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))
      }
    | f, E-Subst t t' e phi h p => \let
      | (ax : DecSizedEnsemble, sax, pax) => sequentProofUsesFiniteAxioms h
      \in (ax.addSized' (equal t t'),
           \case \elim __ \with {
             | byLeft z => sax z
             | byRight z => transport (__ ∈ axioms) z e
           },
           E-Subst t t' (byRight idp) phi (weaken pax (byLeft __)) p)

  \class TermCongruence {L : Language} {n : Nat} (axioms : Ensemble (Formula n)) \extends Equivalence
    | A => Term n
    | fCong (f : Functions)
            (d : Array (Term n) (functionArity f))
            (d' : Array (Term n) (functionArity f))
            (d~d' : \Pi (i : Fin (functionArity f)) -> d i ~ d' i) : apply f d ~ apply f d'
    | relCong  (r : Relations)
               (d : Array (Term n) (relationsArity r))
               (d' : Array (Term n) (relationsArity r))
               (d~d' : \Pi (i : Fin (relationsArity r)) -> d i ~ d' i)
               (h : axioms ⊢ atomic r d) : axioms ⊢ atomic r d'

  \func T~ {L : Language} {n : Nat} (axioms : Ensemble (Formula n)) : TermCongruence \cowith
    | L => L
    | n => n
    | axioms => axioms
    | ~ x y => TruncP (axioms ⊢ equal x y)
    | ~-reflexive => inP (E-Refl idp)
    | ~-symmetric {x} {y} (inP h) => inP (⊢.E-Symm h)
    | ~-transitive {x} {y} {z} (inP h) (inP h') => inP (⊢.E-Trans h h')
    | fCong f d d' d~d' => {?}
    | relCong r d d' d~d' h => {?}

  \func TermInterpretation {L : Language} {n : Nat} (axioms : Ensemble (Formula n)) : Interpretation n =>
    (\new Semantics.Structure {
       | Universe => Quotient {Term n} (~ {T~ axioms})
       | rel => relInterpretation axioms
       | funcs f d => {?}
     },
     \lam f => in~ (var f))
    \where {
      \func relInterpretation {L : Language} {n : Nat} (axioms : Ensemble (Formula n)) (r : Relations) (d : Array (Quotient {Term n} (~ {T~ axioms})) (relationsArity r)) : \Prop =>
        \let d'  => ArrayUtils.mapRepresentatives d
        \in TruncP.rec {Array (Term n) (relationsArity r)}
            {?}
            d'
            (\lam d'' => TruncP (axioms ⊢ atomic r d''))

      \func termInterpretationIsQuotient {L : Language} {axioms : Ensemble (Formula 0)} {t : Term 0}
        : evaluate (TermInterpretation axioms) t = in~ t \elim t
        | var f => idp
        | apply f d => {?}
    }
}