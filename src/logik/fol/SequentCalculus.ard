\import Data.Fin
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set \hiding (#)
\import lambda.GeneralContext
\import logik.fol.FOL
\import logik.fol.FormulaDec
\import logik.fol.Lifting
\import logik.fol.Semantics
\import logik.fol.Substitution
\import sets.Add
\import sets.DecidableSet
\import sets.MySet \hiding (S, ∅)
\import sets.finite.Sized
\import sets.remove
\import sets.subset
\import util.ArrayUtils
\open Semantics (Interpretation, ⊧, ⊫e)

\module SequentCalulus \where {
  \data SequentProof \alias \infix 5 ⊢ {L : Language} {c : TermContext} (axioms : Ensemble (Formula c)) (toShow : Formula c) : \1-Type
  \elim toShow
    | toShow => Ass (toShow ∈ axioms)
    | toShow => PC (psi : Formula c) (add {Formula c} axioms psi ⊢ toShow) (add axioms (notH psi) ⊢ toShow)
    | toShow => Ctr (psi : Formula c)
                    (add axioms (notH toShow) ⊢ psi) (add axioms (notH toShow) ⊢ notH psi)

    -- TODO ...

    | impH x y => impIntro (add axioms x ⊢ y)
    | impH x y => impIntro' (axioms ⊢ notH x)
    | toShow =>   impElim (phi psi : Formula c) ((phi impH psi) ∈ axioms) (add axioms (notH phi) ⊢ toShow) (add axioms psi ⊢ toShow)

    | equal x y => E-Refl (x = y)

    | toShow => E-Sub {c' : TermContext} (s s' : TermSubst c' c)
                      (subEqual : \Pi (i : variable c') -> equal (s i) (s' i) ∈ axioms)
                      (phi : Formula c')
                      (sProof : axioms ⊢ FormulaSubst.subst s phi) (toShow = FormulaSubst.subst s' phi)

    \where {
      \func Contr' {L : Language} {c : TermContext} {axioms :  Ensemble (Formula c)} {toShow : Formula c}
                   (phi : Formula c) (h : axioms ⊢ phi) (h' : axioms ⊢ notH phi) : axioms ⊢ toShow =>
        Ctr phi (weaken h (byLeft __)) (weaken h' (byLeft __))

      \func MP {L : Language} {c : TermContext} {axioms :  Ensemble (Formula c)} {toShow : Formula c}
               (phi : Formula c) (h : axioms ⊢ phi) (h' : add axioms phi ⊢ toShow)
        : axioms ⊢ toShow => PC phi
          h'
          (Contr' phi (weaken h (byLeft __)) (Ass (byRight idp)))

      \func MPs {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)} {toShow : Formula c} {l : Nat}
                (phis : Array (Formula c) l) (hs : DArray (axioms ⊢ phis __)) (h' : add.addMany axioms phis ⊢ toShow)
        : axioms ⊢ toShow \elim l, phis, hs
        | 0, nil, nil => h'
        | suc l, phi :: phis, h :: hs => MP
            phi
            h
            (MPs phis (\lam i => weaken (hs i) (byLeft __))
                (rewrite add.addMany.commute h'))

      \func E-Sub' {L : Language} {c c' : TermContext} {axioms : Ensemble (Formula c)} (s s' : TermSubst c' c)
                   (subEqual : \Pi (i : variable c') -> axioms ⊢ equal (s i) (s' i))
                   (phi : Formula c')
                   (sProof : axioms ⊢ FormulaSubst.subst s phi)
                   {toShow : Formula c}
                   (p : toShow = FormulaSubst.subst s' phi) : axioms ⊢ toShow =>
        \let equalArray => \lam (i : Fin (Context.length c')) => equal (s (∋.fromIndexFin i)) (s' (∋.fromIndexFin i))
        \in MPs
            equalArray
            (\lam i => subEqual (∋.fromIndexFin i))
            (E-Sub s s'
                (\lam i => add.addMany.isInArray {_} {axioms} {equalArray} (∋.toIndexFin i, unfold equalArray $ rewrite variable.fromToIndexFin idp))
                phi
                (weaken sProof add.addMany.isInOriginal)
                p
            )

      --      \func E-Sub'-TruncP {L : Language} {c c' : TermContext} {axioms : Ensemble (Formula c)} (s s' : TermSubst c' c)
      --                   (subEqual : \Pi (i : variable c') -> TruncP (axioms ⊢ equal (s i) (s' i)))
      --                   (phi : Formula c')
      --                   (sProof : axioms ⊢ subst s phi)
      --                   {toShow : Formula c}
      --                   (p : toShow = subst s' phi) : TruncP (axioms ⊢ toShow)
      --        => TruncP.map (truncMap subEqual) (E-Sub' s s' __ phi sProof p)
      --
--      \func E-Subst {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
      --                     (t t' : Term n) (te : equal t t' ∈ axioms) (phi : Formula (suc n))
      --                     (h : axioms ⊢ sub phi t)
      --                     {toShow : Formula c} (p : toShow = sub phi t') : axioms ⊢ toShow =>
      --        E-Sub' (sub.substFunction t) (sub.substFunction t')
      --            (\case \elim __ \with {
      --              | 0 => Ass te
      --              | suc _ => E-Refl idp
      --            })
      --            phi
      --            h
      --            p
      --
--      \func E-Subst' {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
      --                     (t t' : Term c) (te : axioms ⊢ equal t t') (phi : Formula (c ∕ ()))
      --                     (h : axioms ⊢ sub phi t)
      --                     {toShow : Formula c} (p : toShow = sub phi t') : axioms ⊢ toShow =>
      --        MP (equal t t') te (E-Subst t t' (byRight idp) phi (weaken h (byLeft __)) p)
      --


      \func E-Symm {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                   {x y : Term c}
                   (h : axioms ⊢ equal x y) : axioms ⊢ equal y x =>
        E-Sub' {_} {c} {c ∕ ()} {axioms}
            (sub.extendsOne {FOLTermSub} x)
            (sub.extendsOne {FOLTermSub} y)
            (\case \elim __ \with {
              | Z p => h
              | S l => E-Refl idp
            })
            (equal (var #0) (TermLifting.lift x))
            (rewrite TermLifting.subLift (E-Refl idp))
            (rewrite TermLifting.subLift idp)

      \func E-Trans {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                    {x y z : Term c}
                    (h : axioms ⊢ equal x y) (h' : axioms ⊢ equal y z) : axioms ⊢ equal x z =>
        E-Sub'
            (sub.extendsOne {FOLTermSub} y)
            (sub.extendsOne {FOLTermSub} z)
            (\case \elim __ \with {
              | Z p => h'
              | S l => E-Refl idp
            })
            (equal (TermLifting.lift x) (var #0))
            (rewrite TermLifting.subLift h)
            (rewrite TermLifting.subLift idp)

      --              \let h'' :  add axioms (equal y z) ⊢ equal x y => weaken h (byLeft __)
      --              \in E-Subst' y z h'
      --                  (equal (Term.lift x) (var 0))
      --                  (unfold sub $ rewrite (subTermLift _ (\lam f => idp)) h)
      --                  (unfold sub $ rewrite (subTermLift _ (\lam f => idp)) idp)

      -- TruncP because thats where we use it

      \func CP3 {L : Language} {c : TermContext}
                {axioms : Ensemble (Formula c)} {x y : Formula c}
                (h : add axioms (notH y) ⊢ x)
        : add axioms (notH x) ⊢ y => Ctr x
          (weaken h (\case __ \with {
            | byLeft a => byLeft (byLeft a) | byRight b => byRight b
          }))
          (Ass (byLeft (byRight idp)))

      \func elim-notnot {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)} {f : Formula c}
                        (h : axioms ⊢ notH (notH f))
        : axioms ⊢ f => MP (notH (notH f)) h (CP3 (Ass (byRight idp)))

      --      \func intro-notnot {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)} {f : Formula c}
      --                         (h : axioms ⊢ f)
      --        : axioms ⊢ notH (notH f) => {?}

      \func CP4 {L : Language} {c : TermContext}
                {axioms : Ensemble (Formula c)} {x y : Formula c}
                (h : add axioms y ⊢ notH x)
        : add axioms x ⊢ notH y =>
        Ctr x
            (Ass (byLeft (byRight idp)))
            (MP y
                (elim-notnot (Ass (byRight idp)))
                (weaken h (\case __ \with {
                  | byLeft a => byLeft (byLeft (byLeft a)) | byRight b => byRight b
                })))

      --      \func intro-not {L : Language} {c : TermContext}
      --                      {axioms : Ensemble (Formula c)} {f : Formula c}
      --                      (h : Not (axioms ⊢ f))
      --        : axioms ⊢ notH f => PC f
      --          {?}
      --          (Ass (byRight idp))

      \func CtrNot {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                   {f : Formula c}
                   (psi : Formula c)
                   (h1 : add axioms f ⊢ psi)
                   (h2 : add axioms f ⊢ notH psi)
        : axioms ⊢ notH f => Ctr psi
          (MP f
              (elim-notnot (Ass (byRight idp)))
              (weaken h1 (\case __ \with {
                | byLeft a => byLeft (byLeft a) | byRight b => byRight b
              })))
          (MP f
              (elim-notnot (Ass (byRight idp)))
              (weaken h2 (\case __ \with {
                | byLeft a => byLeft (byLeft a) | byRight b => byRight b
              })))

      \func elim-or {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                    {x y toShow : Formula c} (h : (x orH y) ∈ axioms)
                    (h1 : add axioms x ⊢ toShow)
                    (h2 : add axioms y ⊢ toShow)
        : axioms ⊢ toShow => impElim (notH x) y h
          (MP x (elim-notnot (Ass (byRight idp))) (weaken h1 (\case __ \with {
            | byLeft a => byLeft (byLeft a)
            | byRight b => byRight b
          })))
          h2

      --      \func intro-or1 {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
      --                      {x y : Formula c} (h : axioms ⊢ x) : axioms ⊢ x orH y => impIntro' (intro-notnot h)

      \func intro-or2 {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                      {x y : Formula c} (h : axioms ⊢ y) : axioms ⊢ x orH y => impIntro (weaken h (byLeft __))

      \func intro-and {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                      {x y : Formula c} (h1 : axioms ⊢ x) (h2 : axioms ⊢ y) : axioms ⊢ x andH y =>
        \let | z : Formula c => x -- does not matter
             | axioms' => add axioms (notH x orH notH y)
             | proof : \Pi (xi : Formula c) -> axioms' ⊢ xi
             => \lam xi =>  elim-or {L} {c} {axioms'} {notH x} {notH y} {xi} (byRight idp)
                   (CP3 (weaken h1 (\lam e => byLeft (byLeft e))))
                   (CP3 (weaken h2 (\lam e => byLeft (byLeft e))))
        \in CtrNot
            z
            (proof z)
            (proof (notH z))

      \func intro-<->H {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                       {x y : Formula c} (h1 : axioms ⊢ x impH y) (h2 : axioms ⊢ y impH x)
        : axioms ⊢ (x <->H y) => intro-and h1 h2

      \func EqualRel {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                     {r : L.Relations} {d d' : Array (Term c) (L.relationsArity r)}
                     (he : \Pi (i : Fin (L.relationsArity r)) -> axioms ⊢ equal (d i) (d' i))
                     (h : axioms ⊢ atomic r d) : axioms ⊢ atomic r d' => {?}

      \func EqualApply {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                       {f : L.Functions} {d d' : Array (Term c) (L.functionArity f)}
                       (h : \Pi (i : Fin (L.functionArity f)) -> axioms ⊢ equal (d i) (d' i))
        : axioms ⊢ equal (apply f d) (apply f d') =>
        \let
          | s => subN.extendsN {FOLTermSub} {_} {ArrayUtils.arrayOf' ()} d
          | s' => subN.extendsN {FOLTermSub} {_} {ArrayUtils.arrayOf' ()} d'
          | phi => equal (apply f (\lam i => TermLifting.liftN (d i))) (apply f arrayOfVars)
        \in
          ⊢.E-Sub' s s' (\lam i => equalExtendsN h i) phi
              (E-Refl (pmap (apply f) $
              ext $ ext (\lam j => TermLifting.subLiftN *> inv (subN.extendsNSecondConss {FOLTermSub} d j))
              ))

              (
                \let
                  | h1 : d = {Array (Term c) (L.functionArity f)} (\lam i => subN {FOLTermSub} (TermLifting.liftN (d i)) d') =>
                    ext $ ext $ (\lam j => inv TermLifting.subLiftN)

                  | h2 : d' = {Array (Term c) (L.functionArity f)} (\lam i => subN {FOLTermSub} (arrayOfVars i) d') =>
                    ext $ ext $ (\lam j => \let h : d' j = subN {FOLTermSub} (arrayOfVars j) d' => inv $ arrayOfVarsSubN j d' \in h)

                  | goal : equal (apply f d) (apply f d') = FormulaSubst.subst s' phi =>
                    pmap2 equal (pmap (apply f) h1) (pmap (apply f) h2)
                \in goal)

        \where {
          \func arrayOfVars {L : Language} {c : TermContext} {length : Nat} : Array (Term {L} (c Context.∕∕ ArrayUtils.arrayOf () {length})) length =>
            \lam i => var (∋.secondConss i idp)

          \func arrayOfVarsSubN {L : Language} {c : TermContext} {length : Nat} (i : Fin length) (d : Array (Term c) length)
            : subN {FOLTermSub} (arrayOfVars i) d = d i => subN.extendsNSecondConss {FOLTermSub} d i

          \func equalExtendsN {L : Language} {c : TermContext} {axioms : Ensemble (Formula c)}
                              {l : Nat} {d d' : Array (Term c) l}
                              (de : \Pi (i : Fin l) -> axioms ⊢ equal (d i) (d' i))
                              (i : c Context.∕∕ ArrayUtils.arrayOf () {l} ∋ ())
            : axioms ⊢ equal (subN.extendsN {FOLTermSub} d i) (subN.extendsN {FOLTermSub} d' i)
          \elim l, i
            | 0, i => ⊢.E-Refl idp
            | suc l, Z p => de 0
            | suc l, S i => equalExtendsN (\lam j => de (fsuc j)) i
        }
    }

  \func weaken {L : Language} {c : TermContext} {axioms axioms' : Ensemble (Formula c)} {toShow : Formula c}
               (h : axioms ⊢ toShow) (sub : axioms ⊆ axioms') : axioms' ⊢ toShow \elim toShow, h
    | toShow, Ass e => Ass (sub e)
    | toShow, PC psi h1 h2 => PC psi
        (weaken h1 (\case __ \with {
          | byLeft a => byLeft (sub a) | byRight b => byRight b
        }))
        (weaken h2 (\case __ \with {
          | byLeft a => byLeft (sub a) | byRight b => byRight b
        }))
    | toShow, Ctr psi h1 h2 => Ctr psi
        (weaken h1 (\case __ \with {
          | byLeft a => byLeft (sub a) | byRight b => byRight b
        }))
        (weaken h2 (\case __ \with {
          | byLeft a => byLeft (sub a) | byRight b => byRight b
        }))
    | equal x y, E-Refl p => E-Refl p
    | toShow, E-Sub s s' subEqual phi h p => E-Sub s s' (\lam i => sub (subEqual i)) phi (weaken h sub) p
    | impH x toShow, impIntro h => impIntro (weaken h (⊆.unionSubset' sub ⊆.refl))
    | impH x toShow, impIntro' h => impIntro' (weaken h sub)
    | toShow, impElim x y h h1 h2 => impElim x y (sub h) (weaken h1 (⊆.unionSubset' sub ⊆.refl)) (weaken h2 (⊆.unionSubset' sub ⊆.refl))

  \func proofIsEntails
    {L : Language} {from : Ensemble (Formula ∅)} {to : Formula ∅}
    (decidable : \Pi (I : Interpretation ∅) (f : Formula ∅) -> Dec (I ⊧ f))
    (h : from ⊢ to) : from ⊫e to
  \elim to, h
    | to, Ass e => \lam I h => h e
    | to, PC psi h1 h2 => \lam I h =>
        \let dec : Dec (I ⊧ psi) => decidable I psi
        \in \case dec \with {
          | yes e => proofIsEntails decidable h1 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p e
          })
          | no n => proofIsEntails decidable h2 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p n
          })
        }
    | to, Ctr psi h1 h2 => \lam I h => \case decidable I to \with {
      | yes e => e
      | no n =>
        \let
          | Ipsi => proofIsEntails decidable h1 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p n
          })
          | InotPsi => proofIsEntails decidable h2 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p n
          })
        \in absurd (InotPsi Ipsi)
    }
    | equal x y, E-Refl idp => \lam I h => idp
    | toShow, E-Sub {c'} s s' subEqual phi h idp => \lam I h1 =>
        \let
          | IphiT => proofIsEntails decidable h I h1
          | substIs  : Interpretation.subst I s ⊧ phi => (Semantics.substitutionLemma phi s I).1 IphiT
          | substIs' : Interpretation.subst I s' ⊧ phi => Semantics.substitutionLemma.coincidenceLemma phi substIs (\lam f => idp) (\lam r => idp)
              (\lam {i} free => h1 $ subEqual i)
        \in (Semantics.substitutionLemma phi s' I).2 substIs'
    | impH x to, impIntro h => \lam I mf mx => proofIsEntails decidable h I (\case __ \with {
      | byLeft a => mf a
      | byRight b => rewriteI b mx
    })
    | impH x to, impIntro' h => \lam I mf mx => absurd (proofIsEntails decidable h I mf mx)
    | toShow, impElim x y el h1 h2 => \lam I h => \case decidable I x \with {
      | yes Ix => proofIsEntails decidable h2 I (\case __ \with {
        | byLeft inFrom => h inFrom
        | byRight =y => rewriteI =y $ h el Ix
      })
      | no Inx => proofIsEntails decidable h1 I (\case __ \with {
        | byLeft inFrom => h inFrom
        | byRight =nx => rewriteI =nx $ Inx
      })
    }

  --  \func subModel {L : Language} {I : Interpretation ∅} {phi : Formula (Context.∅ ∕ ())} {t t' : Term ∅}
  --                 (h : I ⊧ sub phi t) (e : evaluate I t = evaluate I t')
  --    : I ⊧ sub phi t' => substModel phi (\lam {f : Fin 1} f1 => \case \elim f \with {
  --    | zero => e
  --  }) h
  --    \where {
  --      \func substModel {L : Language} {c c' : TermContext} {I : Interpretation m} (phi : Formula c)
  --                       {s s' : Subst n m} (freeSame : \Pi {f : variable c} (Formula.FreeVar phi f) -> evaluate I (s f) = evaluate I (s' f))
  --                       (h : I ⊧ subst s phi)
  --        : I ⊧ subst s' phi
  --      \elim phi
  --        | equal x y => evalSubst x (\lam fr => inv (freeSame (byLeft fr))) *> h *> evalSubst y (\lam fr => freeSame (byRight fr))
  --        | atomic r d => transport (Semantics.rel {I.1} r)
  --            (ext (ext (\lam j => rewriteF (inv $ subTermsAt j, inv $ subTermsAt j) (evalSubst (d j) (\lam {k} free => freeSame $ inP (j, free))))))
  --            h
  --        | impH x phi => \lam mo =>
  --            \let xs : I ⊧ subst s x => substModel x (\lam fr => inv (freeSame (byLeft fr))) mo
  --            \in substModel phi (\lam fr => freeSame (byRight fr)) (h xs)
  --        | notH phi => \lam mo => h (substModel phi (\lam fr => inv (freeSame fr)) mo)
  --        | forallH phi => \lam x => substModel
  --            phi
  --            {extends s}
  --            (\lam {k} free => \case \elim k, free \with {
  --              | 0, free => idp
  --              | suc k, free => \let fs => freeSame free \in unfold extends (subOneRename (s k) *> fs *> inv (subOneRename (s' k)))
  --            })
  --            (h x)
  --    }

  \func sequentProofUsesFiniteAxioms {L : DecLanguage} {axioms : DecElementEnsemble (Formula ∅)} {f : Formula ∅}
                                     (h : axioms ⊢ f) : \Sigma (reducedAxioms : DecSizedEnsemble (Formula ∅)) (reducedAxioms.S ⊆ axioms) (reducedAxioms ⊢ f)
  \elim f, h
    | f, Ass e => (DecSizedEnsemble.fromSizedEnsemble $ SizedEnsemble.singleSized f, ⊆.singleSubset e, Ass idp)
    | equal x y, E-Refl p => (DecSizedEnsemble.fromSizedEnsemble $ SizedEnsemble.emptySized, ⊆.∅-is-⊆, E-Refl p)
    | f, PC psi h1 h2 =>
      \let
        | (ax1 : DecSizedEnsemble, sax1, pax1) => sequentProofUsesFiniteAxioms {_} {axioms.addElement psi} h1
        | (ax2 : DecSizedEnsemble, sax2, pax2) => sequentProofUsesFiniteAxioms {_} {axioms.addElement (notH psi)} h2
        -- we need to remove psi from ax1 (if it has it) unless it was already present in axioms
      \in \case axioms.decElement psi, ax1.decElement psi, axioms.decElement (notH psi), ax2.decElement (notH psi) \with {
        -- psi is already in axioms, we can cut the tree to that branch of PC
        | yes e, _, _, _ => (ax1, ⊆.trans sax1 (⊆.unionSubset ⊆.refl (⊆.singleSubset e)), pax1)
        -- same thing for notH psi
        | _, _, yes e, _ => (ax2, ⊆.trans sax2 (⊆.unionSubset ⊆.refl (⊆.singleSubset e)), pax2)
        -- psi and notH psi need to be removed
        | no n, yes psiIn, no n1, yes nPsiIn =>
          \let
            | ax1' : DecSizedEnsemble => ax1.removeSized psiIn
            | ax2' : DecSizedEnsemble => ax2.removeSized nPsiIn
            | axioms' => ax1'.unionSized ax2'
            | ax1sub : ax1.S ⊆ add axioms' psi => \lam {x} e => \case decideEq psi x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft (e, n2))
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH psi) => \lam {x} e => \case decideEq (notH psi) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byRight (e, n2))
            }
          \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) (⊆.removeAdd sax2),
               PC psi (weaken pax1 ax1sub) (weaken pax2 ax2sub)
          )

        -- only psi needs to be removed
        | no n, yes psiIn, no n1, no n2 =>
          \let
            | ax1' : DecSizedEnsemble => ax1.removeSized psiIn
            | axioms' => ax1'.unionSized ax2
            | sax2' : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n2) $ ⊆.removeAdd sax2
            | ax1sub : ax1.S ⊆ add axioms' psi => \lam {x} e => \case decideEq psi x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft (e, n2))
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH psi) => \lam {x} e => byLeft (byRight e)
          \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) sax2', PC psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))

        -- only notH psi needs to be removed
        | no n, no n1, no n2, yes nPsiIn =>
          \let
            | ax2' : DecSizedEnsemble => ax2.removeSized nPsiIn
            | axioms' => ax1.unionSized ax2'
            | sax1' : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax1
            | ax1sub : ax1.S ⊆ add axioms' psi => \lam {x} e => \case decideEq psi x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft e)
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH psi) => \lam {x} e => \case decideEq (notH psi) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byRight (e, n2))
            }
          \in (axioms', ⊆.unionSubset sax1' (⊆.removeAdd sax2),
               PC psi (weaken pax1 ax1sub) (weaken pax2 ax2sub)
          )
        -- we don't need to remove anything
        | no n, no n1, no n2, no n3 =>
          \let
            | ax1sub : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) (⊆.removeAdd sax1)
            | ax2sub : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n3) (⊆.removeAdd sax2)
          \in (ax1.unionSized ax2, ⊆.unionSubset ax1sub ax2sub, PC psi (weaken pax1 (byLeft $ byLeft __)) (weaken pax2 (byLeft $ byRight __)))
      }

    | f, Ctr psi h1 h2 =>
      \let
        | (ax1 : DecSizedEnsemble, sax1, pax1) => sequentProofUsesFiniteAxioms {_} {axioms.addElement (notH f)} h1
        | (ax2 : DecSizedEnsemble, sax2, pax2) => sequentProofUsesFiniteAxioms {_} {axioms.addElement (notH f)} h2
      \in \case axioms.decElement (notH f), ax1.decElement (notH f), ax2.decElement (notH f) \with {
        | yes e, _, _ => (ax1.unionSized ax2,
                          ⊆.unionSubset
                              (⊆.trans sax1 (⊆.unionSubset ⊆.refl (\lam {x} x=notH => transport (__ ∈ axioms.S) x=notH e)))
                              (⊆.trans sax2 (⊆.unionSubset ⊆.refl (\lam {x} x=notH => transport (__ ∈ axioms.S) x=notH e))),
                          Ctr psi (weaken pax1 (\lam z => byLeft (byLeft z))) (weaken pax2 (\lam z => byLeft (byRight z))))
        | no n, yes e, yes e1 =>
          \let
            | ax1' : DecSizedEnsemble => ax1.removeSized e
            | ax2' : DecSizedEnsemble => ax2.removeSized e1
            | axioms' => ax1'.unionSized ax2'
            | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft (e, n2))
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byRight (e, n2))
            }
          \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) (⊆.removeAdd sax2),
               Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub)
          )
        | no n, yes e, no n1 =>
          \let
            | ax1' : DecSizedEnsemble => ax1.removeSized e
            | axioms' => ax1'.unionSized ax2
            | sax2' : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax2
            | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byLeft (e, n2))
            }
            | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam z => byLeft (byRight z)
          \in (axioms', ⊆.unionSubset (⊆.removeAdd sax1) sax2',
               Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))
        | no n, no n1, yes e =>
          \let
            | ax2' : DecSizedEnsemble => ax2.removeSized e
            | axioms' => ax1.unionSized ax2'
            | sax1' : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax1
            | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam z => byLeft (byLeft z)
            | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam {x} e => \case decideEq (notH f) x \with {
              | yes e1 => byRight e1
              | no n2 => byLeft (byRight (e, n2))
            }
          \in (axioms', ⊆.unionSubset sax1' (⊆.removeAdd sax2),
               Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))
        | no n, no n1, no n2 =>
          \let
            | axioms' => ax1.unionSized ax2
            | sax1' : ax1.S ⊆ axioms => rewrite (remove.alreadyGone n1) $ ⊆.removeAdd sax1
            | sax2' : ax2.S ⊆ axioms => rewrite (remove.alreadyGone n2) $ ⊆.removeAdd sax2
            | ax1sub : ax1.S ⊆ add axioms' (notH f) => \lam z => byLeft (byLeft z)
            | ax2sub : ax2.S ⊆ add axioms' (notH f) => \lam z => byLeft (byRight z)
          \in (axioms', ⊆.unionSubset sax1' sax2',
               Ctr psi (weaken pax1 ax1sub) (weaken pax2 ax2sub))
      }
    | toShow, E-Sub s s' subEqual phi h p =>
      \let
        | (ax : DecSizedEnsemble, sax, pax) => sequentProofUsesFiniteAxioms h
        | eqArray => \lam (i : Fin (Context.length _)) => equal (s (∋.fromIndexFin i)) (s' (∋.fromIndexFin i))
      \in (ax.addSizedMany' eqArray,
           \lam {x} e => \case with.addMany.isInOr e \with {
             | byLeft h1 => sax h1
             | byRight (i, p) => rewriteI p $ subEqual (∋.fromIndexFin i)
           },
           E-Sub s s'
               (\lam i => add.addMany.isInArray {_} {ax} {eqArray} {equal (s i) (s' i)} (∋.toIndexFin i, unfold eqArray (rewrite variable.fromToIndexFin idp)))
               phi
               (weaken pax add.addMany.isInOriginal)
               p
      )
    | impH x f, impIntro h =>
      \let (ax : DecSizedEnsemble, sax, pax) => sequentProofUsesFiniteAxioms {_} {axioms.addElement x} h
      \in \case axioms.decElement x, ax.decElement x \with {
        | yes e, _ => (ax, ⊆.trans sax (⊆.unionSubset ⊆.refl (⊆.singleSubset e)), impIntro (weaken pax (byLeft __)))
        | no n, yes e => (ax.removeSized e, ⊆.removeAdd sax, impIntro (rewriteI (remove.addBack e _) pax))
        | no n, no n1 => (ax, \lam {y} e => \case sax e \with {
          | byLeft a => a
          | byRight b => absurd (n1 (rewrite b e))
        }, impIntro (weaken pax (byLeft __)))
      }
    | impH x f, impIntro' h => \let (ax, sax, pax) => sequentProofUsesFiniteAxioms h \in (ax, sax, impIntro' pax)
    | toShow, impElim phi psi impIn h1 h2 =>
      -- phi -> psi
      -- A, n phi |- S
      -- A, psi |- S
      -- ----------------
      -- A |- S

      \let
        | addAxiomsNot : DecElementEnsemble (Formula ∅) => \new DecElementEnsemble {
          | E => Formula ∅
          | S => add axioms (notH phi)
          | decElement x => \case axioms.decElement x, decideEq {FormulaDec} (notH phi) x \with {
            | yes e1, _ => yes (byLeft e1)
            | _, yes e1 => yes (byRight e1)
            | no n, no n1 => no (\case __ \with {
              | byLeft a => n a
              | byRight b => n1 b
            })
          }
        }
        | addAxioms : DecElementEnsemble (Formula ∅) => \new DecElementEnsemble {
          | E => Formula ∅
          | S => add axioms psi
          | decElement x => \case axioms.decElement x, decideEq {FormulaDec} psi x \with {
            | yes e1, _ => yes (byLeft e1)
            | _, yes e1 => yes (byRight e1)
            | no n, no n1 => no (\case __ \with {
              | byLeft a => n a
              | byRight b => n1 b
            })
          }
        }

        | (h1axioms : DecSizedEnsemble, h1subset, h1Proof) => sequentProofUsesFiniteAxioms {_} {addAxiomsNot} h1
        | (h2axioms : DecSizedEnsemble, h2subset, h2Proof) => sequentProofUsesFiniteAxioms {_} {addAxioms} h2
        | h1Pure : DecSizedEnsemble => h1axioms.removeSized' (notH phi)
        | h2Pure : DecSizedEnsemble => h2axioms.removeSized' psi
        | unionAxioms : DecSizedEnsemble => h1Pure.unionSized h2Pure
        | withAdded : DecSizedEnsemble => unionAxioms.addSized' (phi impH psi)
      \in \case axioms.decElement psi \with {
        | yes psiIn =>
          -- then h2 is sufficient
          (h2axioms, ⊆.trans h2subset (⊆.unionSubset ⊆.refl (⊆.singleSubset psiIn)), h2Proof)

        -- then we need to remove psi from the union
        | no psiNotIn => \case axioms.decElement (notH phi) \with {
          | yes nPhiIn =>
            -- then h1 is sufficient
            (h1axioms, ⊆.trans h1subset (⊆.unionSubset ⊆.refl (⊆.singleSubset nPhiIn)), h1Proof)

          | no nPhiNotIn =>
            -- we need to craft a finite implemtation of impElim (union of h1 and h2 minus psi / not phi and keep (psi -> phi))
            (withAdded,
             ⊆.unionSubset (⊆.unionSubset (⊆.removeAdd h1subset) (⊆.removeAdd h2subset)) (⊆.singleSubset impIn),
             impElim phi psi (byRight idp)
                 (weaken h1Proof (\lam {x} e => \case decideEq (notH phi) x \with {
                   | yes x=notPhi => byRight x=notPhi
                   | no x/=notPhi => byLeft (byLeft (byLeft (e, x/=notPhi)))
                 }))
                 (weaken h2Proof (\lam {x} e => \case decideEq psi x \with {
                   | yes x=psi => byRight x=psi
                   | no x/=psi => byLeft (byLeft (byRight (e, x/=psi)))
                 })))
        }
      }
}