\import Function.Meta ($)
\import Logic
\import Meta
\import Misc
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Util
\import logik.fol.FOL
\import logik.fol.Semantics
\import sets.Add
\import sets.Finite
\import sets.MySet
\import sets.subset
\import sets.union
\import util.ArrayUtils
\open Semantics (Interpretation, evaluate, ⊧)
\open Term (AnyFreeVar, FreeVar, lift)
\open Formula (Subst, extends, sub, subTerm, subTerms, subTermsAt, subst)
\open Interpretation (subOneRename)
\open Interpretation (subOneRename)
\open Interpretation (subOneRename)
\open Interpretation (subOneRename)
\open Interpretation (subOneRename)
\open Interpretation (subOneRename)

\module SequentCalulus \where {


  -- TODO finite axioms

  \data SequentProof \alias \infix 6 ⊢ {L : Language} (axioms : Ensemble (Formula 0)) (toShow : Formula 0)
  \elim toShow
    | toShow => Ass (toShow ∈ axioms)
    | toShow => PC (psi : Formula 0) (add axioms psi ⊢ toShow) (add axioms (notH psi) ⊢ toShow)
    | toShow => Ctr (psi : Formula 0)
                    (add axioms (notH toShow) ⊢ psi) (add axioms (notH toShow) ⊢ (notH psi))

    -- TODO ...

    | equal x y => E-Refl (x = y)
    | toShow => E-Subst (t t' : Term 0) (equal t t' ∈ axioms)
                        (phi : Formula 1)
                        (axioms ⊢ sub phi t)
                        (p : toShow = sub phi t')
    \where {
      \func Contr' {L : Language} {axioms :  Ensemble (Formula 0)} {toShow : Formula 0}
                   (phi : Formula 0) (h : axioms ⊢ phi) (h' : axioms ⊢ notH phi) : axioms ⊢ toShow =>
        Ctr phi (weaken h (byLeft __)) (weaken h' (byLeft __))

      \func MP {L : Language} {axioms :  Ensemble (Formula 0)} {toShow : Formula 0}
               (phi : Formula 0) (h : axioms ⊢ phi) (h' : add axioms phi ⊢ toShow)
        : axioms ⊢ toShow => PC phi
          h'
          (Contr' phi (weaken h (byLeft __)) (Ass (byRight idp)))
    }

  \func weaken {L : Language} {axioms axioms' : Ensemble (Formula 0)} {toShow : Formula 0}
               (h : axioms ⊢ toShow) (s : axioms ⊆ axioms') : axioms' ⊢ toShow \elim toShow, h
    | toShow, Ass e => Ass (s e)
    | toShow, PC psi h1 h2 => PC psi
        (weaken h1 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
        (weaken h2 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
    | toShow, Ctr psi h1 h2 => Ctr psi
        (weaken h1 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
        (weaken h2 (\case __ \with {
          | byLeft a => byLeft (s a) | byRight b => byRight b
        }))
    | equal x y, E-Refl p => E-Refl p
    | toShow, E-Subst t t' e phi h p => E-Subst t t' (s e) phi (weaken h s) p

  \func entails \alias \infix 6 ⊫e {L : Language} (from : Ensemble (Formula 0)) (to : Formula 0) =>
    \Pi (I : Interpretation 0) (h : \Pi {f : Formula 0} (f ∈ from) -> I ⊧ f) -> I ⊧ to

  -- TODO how should the classical requirement be handled?

  \func proofIsEntails
    {L : Language} {from : Ensemble (Formula 0)} {to : Formula 0}
    (decidable : \Pi (I : Interpretation 0) (f : Formula 0) -> Dec (I ⊧ f))
    (h : from ⊢ to) : from ⊫e to
  \elim to, h
    | to, Ass e => \lam I h => h e
    | to, PC psi h1 h2 => \lam I h =>
        \let dec : Dec (I ⊧ psi) => decidable I psi
        \in \case dec \with {
          | yes e => proofIsEntails decidable h1 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p e
          })
          | no n => proofIsEntails decidable h2 I (\case __ \with {
            | byLeft a => h a
            | byRight p => rewriteI p n
          })
        }
    | to, Ctr psi h1 h2 => \lam I h => \case decidable I to \with {
      | yes e => e
      | no n => \let
        | Ipsi => proofIsEntails decidable h1 I (\case __ \with {
          | byLeft a => h a
          | byRight p => rewriteI p n
        })
        | InotPsi => proofIsEntails decidable h2 I (\case __ \with {
          | byLeft a => h a
          | byRight p => rewriteI p n
        })
                \in absurd (InotPsi Ipsi)
    }
    | equal x y, E-Refl idp => \lam I h => idp
    | to, E-Subst t t' e phi h idp => \lam I h1 =>
        \let
          | p => h1 e
          | IphiT => proofIsEntails decidable h I h1
        \in subModel IphiT p

  \func subModel {L : Language} {I : Interpretation 0} {phi : Formula 1} {t t' : Term 0}
                 (h : I ⊧ sub phi t) (e : evaluate I t = evaluate I t')
    : I ⊧ sub phi t' => substModel phi (\lam {f : Fin 1} f1 => \case \elim f \with {
    | zero => e
  }) h
    \where {
      \func substModel {L : Language} {n m : Nat} {I : Interpretation m} (phi : Formula n)
                       {s s' : Subst n m} (freeSame : \Pi {f : Fin n} (Formula.FreeVar phi f) -> evaluate I (s f) = evaluate I (s' f))
                       (h : I ⊧ subst s phi)
        : I ⊧ subst s' phi
      \elim phi
        | equal x y => (evalSubst x (\lam fr => inv (freeSame (byLeft fr)))) *> h *> (evalSubst y (\lam fr => freeSame (byRight fr)))
        | atomic r d => transport (Semantics.rel {I.1} r)
            (ext (ext (\lam j => rewriteF (inv $ subTermsAt j, inv $ subTermsAt j) (evalSubst (d j) (\lam {k} free => freeSame $ inP (j, free))))))
            h
        | impH x phi => \lam mo => \let xs : I ⊧ subst s x => substModel x (\lam fr => inv (freeSame (byLeft fr))) mo
                                   \in substModel phi (\lam fr => freeSame (byRight fr)) (h xs)
        | notH phi => \lam mo => h (substModel phi (\lam fr => inv (freeSame fr)) mo)
        | forallH phi => \lam x => substModel
            phi
            {extends s}
            (\lam {k} free => \case \elim k, free \with {
              | 0, free => idp
              | suc k, free => \let fs => freeSame free \in unfold (extends) (subOneRename (s k) *> fs *> (inv (subOneRename (s' k))))
            })
            (h x)

      \func evalSubst {L : Language} {n m : Nat} {I : Interpretation m} (t : Term n)
                      {s s' : Subst n m} (h : \Pi {f : Fin n} (FreeVar t f) -> evaluate I (s f) = evaluate I (s' f))
        : evaluate I (subTerm s t) = evaluate I (subTerm s' t)
      \elim t
        | var f => h idp
        | apply f d => pmap (Semantics.funcs {I.1} f)
            (ext (ext (\lam j =>
                \let h' => (evalSubst (d j) (\lam {k} free => h $ inP (j, free)))
                \in rewriteF (inv $ subTermsAt j, inv $ subTermsAt j) h')))
    }

  -- TODO show that it is subset

  \func sequentProofUsesFiniteAxioms {L : Language} {axioms : Ensemble (Formula 0)} {f : Formula 0}
                                     (h : axioms ⊢ f) : \Sigma (reducedAxioms : Ensemble (Formula 0)) (Finite reducedAxioms) (reducedAxioms ⊆ axioms) (reducedAxioms ⊢ f)
  \elim f, h
    | f, Ass e => (single f, Finite.single-finite, \lam {x} e1 => transport axioms e1 e, Ass idp)
    | f, PC psi h1 h2 =>
      \let
        | (ax1, fax1, sax1, p1) => sequentProofUsesFiniteAxioms h1
        | (ax2, fax2, sax2, p2) => sequentProofUsesFiniteAxioms h2
      \in (ax1 ∪ ax2,
           Finite.finite-union fax1 fax2,
           {?},
           PC psi (weaken p1 (\lam {x} e => byLeft (byLeft {?}))) (weaken p2 (\lam {x} e => byLeft (byRight e))))
    | f, Ctr psi h1 h2 =>
      \let
        | (ax1, fax1, sax1, p1) => sequentProofUsesFiniteAxioms h1
        | (ax2, fax2, sax2, p2) => sequentProofUsesFiniteAxioms h2
      \in (ax1 ∪ ax2,
           Finite.finite-union fax1 fax2,
           {?},
           Ctr psi (weaken p1 (\lam {x} e => byLeft (byLeft e))) (weaken p2 (\lam {x} e => byLeft (byRight e))))
    | equal x y, E-Refl p => (∅, Finite.empty-finite, ⊆.∅-is-⊆, E-Refl p)
    | f, E-Subst t t' e phi h p =>
      \let (ax, fax, sax, p') => sequentProofUsesFiniteAxioms h
      \in (add ax (equal t t'),
           Finite.add-finite fax,
           \lam {x} e1 => \case e1 \with {
             | byLeft a => sax a
             | byRight b => transport axioms b e
           },
           E-Subst t t' (byRight idp) phi (weaken p' (byLeft __)) p)

  \func TermCongruence {L : Language} (axioms : Ensemble (Formula 0)) : Equivalence (Term 0) \cowith
    | ~ x y => TruncP (axioms ⊢ equal x y)
    | ~-reflexive => inP (E-Refl idp)
    | ~-symmetric {x} {y} (inP h) => inP
        (⊢.MP (equal x y)
            h
            (E-Subst x y (byRight idp) (equal (var 0) (lift x)) {?} (pmap2 equal idp (subTermLift x y))))
    | ~-transitive => {?}
    \where {
      \func subTermLift {L : Language} {n : Nat} (x y : Term {L} n) : x = subTerm (\lam (p0 : Fin (suc n)) => (\case p0 \with {
        | zero => y
        | suc i => var i
      })) (lift x) \elim x
        | var f => idp
        | apply f d => {?}
    }
}