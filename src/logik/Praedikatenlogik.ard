\import Data.Array
\import Data.Bool
\import Function
\import Logic
\import Logic.Meta
\import LogicUtil
\import sets.Elements
\import sets.MySet
\import Paths.Meta
\import Set
\import Util
\import sets.Complement
\import sets.Finite
\import sets.Intersect
\import sets.pow
\import sets.subset
\import sets.union

\class Signature
  | Constants : \Set
  | Functions : \Pi (n : Nat) -> \Set
  | Predicates : \Pi (n : Nat) -> \Set

\data Term {S : Signature} (V : \Set)
  | var V
  | const Constants
  | fun {n : Nat} (f : Functions n) (args : Array (Term V) n)

\data Formula {S : Signature} (V : \Set)
  | tt
  | ff
  | p (n : Nat) (P : Predicates n) (args : Array (Term V) n)
  | \infix 6 eq (t1 t2 : Term V)
  | not (f : Formula V)
  | or \alias \infix 6 ∨ (f1 f2 : Formula V)
  | exists (v : V) (a : Formula V)

\cons \infixl 6 and {_ : Signature} {V : \Set} (a b : Formula V) : Formula V => not ((not a) ∨ (not b))
\cons \infix 6 ==> {_ : Signature} {V : \Set} (a b : Formula V) : Formula V => (not a) ∨ b

\func Formulae {_ : Signature} (V : \Set) : \Set => Formula V -> \Prop

\record Structure {S : Signature}
  | Universe : \Set
  | U-Constants : Constants -> Universe
  | U-Functions : \Pi {n : Nat} (Functions n) (Array Universe n) -> Universe
  | U-Predicates : \Pi {n : Nat} (Predicates n) (Array Universe n) -> \Prop

\record Interpretation {Sig : Signature} (V : \Set)
  | S : Structure
  | beta : V -> S.Universe

\func interpret {_ : Signature} {V : \Set}
                (J : Interpretation V) (t : Term V) : J.S.Universe
  \elim t
    | var v => J.beta v
    | const k => J.S.U-Constants k
    | fun f args => J.S.U-Functions f (interpret-args args)

\where {
  \func interpret-args {_ : Signature} {V : \Set} {J : Interpretation V}
                       {n : Nat} (args : Array (Term V) n) : Array J.S.Universe n \elim n, args
    | 0, nil => nil
    | suc n, :: head tail => (interpret J head) :: (interpret-args tail)
}

\func subst {_ : Signature} {V : DecSet} (J : Interpretation V) (v : V) (x : J.S.Universe) : Interpretation V \cowith
  | S => J.S
  | beta => \lam e => \case e == v \with {
    | true => x
    | false => J.beta e
  }

\func models \alias \infix 5 ⊧ {_ : Signature} {V : DecSet}
                               (J : Interpretation V) (f : Formula V) : \Prop \elim f
  | tt => \Sigma
  | ff => Empty
  | p n P args => J.S.U-Predicates P (map (interpret J) args)
  | eq t1 t2 => (interpret J t1) = (interpret J t2)
  | not f => Not (J ⊧ f)
  | ∨ f1 f2 => (J ⊧ f1) || (J ⊧ f2)
  | exists v a => ∃ (x : J.S.Universe) ((subst J v x) ⊧ a)

\where {
  \func rAnd {_ : Signature} {V : DecSet} {J : Interpretation V} {a b : Formula V}
    (h1 : J ⊧ a) (h2 : J ⊧ b) : J ⊧ (a and b)
    => \lam m => \case m \with {
      | byLeft a1 => a1 h1
      | byRight b1 => b1 h2
    }
}

\func valid {_ : Signature} {V : DecSet} (f : Formula V) : \Prop => \Pi (J : Interpretation V) -> J ⊧ f


\func modelsSet \alias \infix 6 ⊧s {_ : Signature} {V : DecSet}
                                   (J : Interpretation V) (fs : Formulae V) : \Type => All fs (J ⊧ __)

\func entails \alias \infix 6 ⊧e {_ : Signature} {V : DecSet} (Phi : Formulae V) (a : Formula V) : \Prop =>
  \Pi (J : Interpretation V) (J ⊧s Phi) -> J ⊧ a

{-

\func listable-entails {_ : Signature} {V : DecSet}
                       {l : List (Formula V)} {a : Formula V}
  : valid (fold l tt (and) ==> a) = (setOf l) ⊧e a
  => ext (\lam v J m => \case v J \with {
    | byLeft Jfold => absurd (Jfold (setToFold m))
    | byRight Ja => Ja
  },
          \lam e J => {?}) -- TODO need LEM?

\where {
  \func setToFold {_ : Signature} {V : DecSet} {J : Interpretation V} {l : List (Formula V)}
    (h : J ⊧s setOf l) : J ⊧ fold l tt (and) \elim l
    | nil => ()
    | :: head tail => ⊧.rAnd (h (head, here idp)) (setToFold (\lam s => h (s.1, there s.2)))
}

-}