\import Algebra.Monoid
\import Arith.Real
\import Data.Array
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Relation.Equivalence
\import manifolds.Topology
\import sets.Image
\import sets.Intersect
\import sets.MySet

\class Hausdorff \extends Topology
  | separable : \Pi (x y : X) (x /= y) -> ∃ (Ux : OpenNeighbourhood x) (Uy : OpenNeighbourhood y) (Ux.1 ∩ Uy.1 = ∅)

\func quotientTopology (Top : Topology) (E : Equivalence Top.X) : Topology \cowith
  | X => Quotient {Top.X} (E.~)
  | T U => Top.open $ PreImage U in~
  | totalInT => Top.totalInT
  | intersectionIn A B hA hB => Top.intersectionIn _ _ hA hB
  | unionIn => {?}

\func Vec (X : \Type) (n : Nat) => DArray {n} (\lam _ => X)

\func euclideanNorm2 {n : Nat} (v : Vec Real n) : Real => fold {Real} {Real} (RealField.+) 0 (map (\lam z => z * z) v)

\func Sphere (n : Nat) : \Set => \Sigma (v : Vec Real (suc n)) (euclideanNorm2 v = {Real} 1)
  \where {
    \func negative {n : Nat} (x : Sphere n) : Sphere n =>
      (
        map RealField.negative x.1,
        \let goal : fold {Real} {Real} (RealField.+) 0 (map (\lam z => RealField.negative z * RealField.negative z) x.1) = {Real} 1 => {?}
        \in goal
      )
  }

\func SphereTopology (n : Nat) : Topology (Sphere n) \cowith
  | T => {?}
  | totalInT => {?}
  | intersectionIn => {?}
  | unionIn => {?}

\func ProjectiveSpace (n : Nat) : Topology => quotientTopology (SphereTopology n) sphere-equiv
  \where {
    \func sphere-equiv {n : Nat} : Equivalence (Sphere n) \cowith
      | ~ x y => (x = y) || (x = Sphere.negative y)
      | ~-reflexive => byLeft idp
      | ~-symmetric e => \case e \with {
        | byLeft a => byLeft (inv a)
        | byRight b => byRight {?}
      }
      | ~-transitive => {?}
  }