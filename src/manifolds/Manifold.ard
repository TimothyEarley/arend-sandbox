\import Algebra.Monoid
\import Arith.Real
\import Data.Array
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Relation.Equivalence
\import manifolds.Topology
\import sets.Family
\import sets.Image
\import sets.Intersect
\import sets.MySet
\import sets.union

\class Hausdorff \extends Topology
  | separable : \Pi (x y : X) (x /= y) -> ∃ (Ux : OpenNeighbourhood x) (Uy : OpenNeighbourhood y) (Ux.1 ∩ Uy.1 = ∅)

\func quotientTopology (Top : Topology) (E : Equivalence Top.X) : Topology \cowith
  | X => Quotient {Top.X} (E.~)
  | T U => Top.open $ PreImage U in~
  | totalInT => Top.totalInT
  | intersectionIn A B hA hB => Top.intersectionIn _ _ hA hB
  | unionIn F h =>
    \let
      -- TODO understand why this is so simple (aka what did I actually do here?)
      | unionInTop : ⋃ (Family.ofQuotientUnpack F) ∈ Top.T => Top.unionIn (Family.ofQuotientUnpack F)
          (\lam {_} (inP (a, idp, e : a ∈ F)) => h e)
      | q : ⋃ (\lam b => ∃ (\Sigma (a : Quotient (E.~) -> \Prop) (b = (\lam (x : Top) => in~ x ∈ a)) (a ∈ F)))
        = {Ensemble Top.X}
      (\lam (a : Top) => in~ a ∈ ⋃ F)
      => extSet
            (\lam {x} (inP (_, inP (f, idp, fF), el)) => inP (f, fF, el))
            (\lam {x} (inP (f, fF, inX)) => inP (\lam (x : Top) => in~ x ∈ f, inP (f, idp, fF), inX))
      | goal : (\lam a => in~ a ∈ ⋃ F) ∈ Top.T  => transport (__ ∈ Top.T) q unionInTop
    \in goal

\func Vec (X : \Type) (n : Nat) => DArray {n} (\lam _ => X)

\func euclideanNorm2 {n : Nat} (v : Vec Real n) : Real => fold {Real} {Real} (RealField.+) 0 (map (\lam z => z * z) v)

\func Sphere (n : Nat) : \Set => \Sigma (v : Vec Real (suc n)) (euclideanNorm2 v = {Real} 1)
  \where {
    \func negative {n : Nat} (x : Sphere n) : Sphere n =>
      (
        map RealField.negative x.1,
        \let goal : fold {Real} {Real} (RealField.+) 0 (map (\lam z => RealField.negative z * RealField.negative z) x.1) = {Real} 1 => {?}
        \in goal
      )
  }

\func SphereTopology (n : Nat) : Topology (Sphere n) \cowith
  | T => {?}
  | totalInT => {?}
  | intersectionIn => {?}
  | unionIn => {?}

\func ProjectiveSpace (n : Nat) : Topology => quotientTopology (SphereTopology n) sphere-equiv
  \where {
    \func sphere-equiv {n : Nat} : Equivalence (Sphere n) \cowith
      | ~ x y => (x = y) || (x = Sphere.negative y)
      | ~-reflexive => byLeft idp
      | ~-symmetric e => \case e \with {
        | byLeft a => byLeft (inv a)
        | byRight b => byRight {?}
      }
      | ~-transitive => {?}
  }