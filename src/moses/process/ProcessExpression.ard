\import Data.Or
\import Paths
\import moses.process.Process
\import sets.MySet
\import sets.finite.FiniteS
\import sets.union

\data ProcessExpression (E : \Set)
  | STOP
  | SKIP
  | BEFORE \alias \infix 6 --> (x : E) (P : ProcessExpression E)
  | OR \alias \infix 6 ⊓ (P Q : ProcessExpression E)

\func traces {E : \Set} (P : ProcessExpression E) : Process.Traces E \elim P
  | STOP => emptyTrace
  | SKIP => emptyTrace ∪ emptyTerminatingTrace
  | --> x P => ((traces P) smap (addToStartOfTrace x)) ∪ emptyTrace
  | ⊓ P Q => (traces P) ∪ (traces Q)

  \where {
    \func emptyTrace {E : \Set} : Process.Traces E => single (inl nil)

    \func emptyTerminatingTrace {E : \Set} : Process.Traces E => single {Process.Trace E} (inr (nil, terminating))

    \func addToStartOfTrace {E : \Set} (x : E) (t : Process.Trace E) : Process.Trace E \elim t
      | inl a => inl (x :: a)
      | inr (l, terminating) => inr (x :: l, terminating)

    \func tracesAreFinite {E : \Set} (P : ProcessExpression E) : FiniteS (traces P)
    \elim P
      | STOP => FiniteS.single-finite
      | SKIP => FiniteS.finite-union FiniteS.single-finite FiniteS.single-finite
      | --> x P => FiniteS.finite-union
          (FiniteS.smap-finite (tracesAreFinite P))
          FiniteS.single-finite
      | ⊓ P Q => FiniteS.finite-union (tracesAreFinite P) (tracesAreFinite Q)
  }

\func process-equiv \alias \infix 6 ≈ {E : \Set} (P Q : ProcessExpression E) : \Prop => traces P = traces Q

\lemma example-equiv {E : \Set} (x : E) (P Q : ProcessExpression E) :
  ((x --> P) ⊓ (x --> Q)) ≈ (x --> (P ⊓ Q)) =>
  \let
    | f => traces.addToStartOfTrace x
    | A => (traces P) smap f
    | B => (traces Q) smap f
    | C => traces.emptyTrace
  \in
    traces ((x --> P) ⊓ (x --> Q))          ==< idp >==
        (traces (x --> P)) ∪ (traces (x --> Q)) ==< idp >==
        (A ∪ C) ∪ (B ∪ C)                       ==< ∪.union-cross A C B C >==
        (A ∪ B) ∪ (C ∪ C)                       ==< pmap ((A ∪ B) ∪ __) (∪.cancel C) >==
        (A ∪ B) ∪ C                             ==< pmap (__ ∪ C) (inv (∪.union-smap (traces P) (traces Q) f)) >==
        (((traces P) ∪ (traces Q)) smap f) ∪ C  ==< idp >==
        ((traces (P ⊓ Q)) smap f) ∪ C           ==< idp >==
        traces (x --> (P ⊓ Q))                  `qed
