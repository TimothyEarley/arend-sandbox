\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Pointed
\import Arith.Nat
\import Data.Array
\import Data.Maybe
\import Data.Or
\import Equiv
\import Meta
\import identity.NatIdentity
\import util.ArrayUtils
\import util.MappedPreOrder
\import sets.Elements
\import sets.Complement
\import sets.finite.FiniteS
\import sets.Intersect
\import sets.pow
\import sets.subset
\import sets.union
\import Logic
\import Logic.Meta
\import LogicUtil
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import sets.MySet
\import Util
\import moses.Process
\import util.Or
\open ArrayUtils (::-)
\open ArrayOrder (<=-prefix)
\open ::- (heads=)

\record Transitionsystem
  | States : \Set
  | Start : States -> \Prop
  | Events : \Set
  | transitions : (\Sigma States Events States) -> \Prop

\func Trace (TS : Transitionsystem) => Array (Or TS.States TS.Events)

\data Traces (TS : Transitionsystem) (t : Trace TS) : \Set
  | start (s : TS.States) (TS.Start s) (t = (inl s) :: nil)
  | seq {s s' : TS.States} {e : TS.Events} (t' : Trace TS)
        (Traces TS (t' ::- (inl s)))
        (TS.transitions (s, e, s'))
        (t = t' ::- (inl s) ::- (inr e) ::- (inl s'))

  \where {
    \func traceEndsWithEventStateOrIsOnlyState {TS : Transitionsystem} {tr : Trace TS}
                                               (trT : Traces TS tr)
      : Or (\Sigma (e : TS.Events) (s : TS.States) (tr' : Trace TS) (Traces TS tr') (tr = tr' ::- inr e ::- inl s))
        (\Sigma (s : TS.States) (tr = inl s :: nil))
    \elim trT
      | start s s1 p => inr (s, p)
      | seq {s} {s'} {e} t' trT t p => inl (e, s', t' ::- inl s, trT, p)

    \func \infix 6 project {A B : \Type} (a : Array A) (f : A -> Maybe B) : Array B \elim a
      | nil => nil
      | :: a arr => \case f a \with {
        | nothing => arr project f
        | just b => b :: arr project f
      }
      \where {
        \func split++ {A B : \Type} {l l' : Array A} {f : A -> Maybe B} : (l ++ l') project f = (l project f) ++ (l' project f)
        \elim l
          | nil => idp
          | :: a arr => mcases \with {
            | nothing => split++
            | just b => pmap {Array B} (b :: __) split++
          }
      }

    \func E-Trace (TS : Transitionsystem) => Array TS.Events

    \func E-Traces (TS : Transitionsystem) (t : E-Trace TS) : \Prop =>
      ∃ (t' : Trace TS) (Traces TS t') (t = t' project inr?)

    \func E-TracesPrefixClosed {TS : Transitionsystem}
                               (t t' : E-Trace TS)
                               (h : E-Traces TS t)
                               (h' : t' <= {ArrayOrder} t) : E-Traces TS t' =>
      \let (t'', prefix) => <=-prefix h' \in helper t t' t'' h prefix
      \where {
        -- use prefix as recursion

        \func helper {TS : Transitionsystem}
                     (t t' t'' : E-Trace TS)
                     (h : E-Traces TS t)
                     (h' : t' ++ t'' = t) : E-Traces TS t' \elim t''
          | nil => \let p : t' = t => rewriteF ++_nil h' \in transportInv (E-Traces TS) p h
          | :: a arr => \case helper t (t' ::- a) arr h (::-.compose++ *> h') \with {
            | inP (x, xTr, p) => \case traceEndsWithEventStateOrIsOnlyState xTr \with {
              -- x is just a state, but that is impossible since it has at least one event, namely 'a'
              | inr (_, x=s) => \let p' : t' ::- a = nil => rewriteF x=s p \in absurd (::-.notNil p')

              -- proper case (idea: if we remove e and s we get y, use that)
              | inl (e, s, y, yTr, x=) =>
                \let p' : t' ::- a = (y project inr?) ::- e =>
                  equation
                      (t' ::- a) {p}
                      (x project inr?) {pmap (__ project inr?) x=}
                      ((y ::- inr e ::- inl s) project inr?) {rewrite (::-.to++, ::-.to++) idp}
                      (((y ++ (inr e :: nil)) ++ (inl s :: nil)) project inr?) {rewrite (project.split++, project.split++) {?}}
                      (((y project inr?) ++ (e :: nil)) ++ nil) {++_nil}
                      ((y project inr?) ++ (e :: nil)) {inv ::-.to++}
                      ((y project inr?) ::- e)
                  | t'=yp => heads= p'

                \in inP (y, yTr, t'=yp)
            }
          }
      }

    \record Process
      | E : \Set
      | Tr : Traces E
      | Tr-non-empty : ∃ (t : Trace E) (Tr t)
      | Tr-closed-under-prefix : PrefixClosure Tr

      \where {
        \func Trace (E : \Set) : \Set => Or (Array E) (\Sigma (Array E) Terminating)
          \where {
            \func toArray {E : \Set} (t : Trace E) : Array (Or E Terminating) \elim t
              | inl a => map inl a
              | inr (l, terminating) => (map inl l) ::- inr terminating
          }

        \func Traces (E : \Set) : \Set => Ensemble (Trace E)

        \instance TraceOrder {E : \Set} : Preorder (Trace E) => mappedPreOrder {ArrayOrder} Trace.toArray

        \func PrefixClosure {E : \Set} (Tr : Traces E) : \Prop => \Pi (t t' : Trace E) (Tr t) (t' <= t) -> Tr t'
      }

    \data Terminating
      | terminating

    -- instead of a seperate alphabet, it is intrinsic to the expression

    \data ProcessExpression (E : \Set)
      | STOP
      | SKIP
      | BEFORE \alias \infix 6 --> (x : E) (P : ProcessExpression E)
      | OR \alias \infix 6 ⊓ (P Q : ProcessExpression E)

    \func traces {E : \Set} (P : ProcessExpression E) : Process.Traces E \elim P
      | STOP => emptyTrace
      | SKIP => emptyTrace ∪ emptyTerminatingTrace
      | --> x P => ((traces P) smap (addToStartOfTrace x)) ∪ emptyTrace
      | ⊓ P Q => (traces P) ∪ (traces Q)

      \where {
        \func emptyTrace {E : \Set} : Process.Traces E => single (inl nil)

        \func emptyTerminatingTrace {E : \Set} : Process.Traces E => single {Process.Trace E} (inr (nil, terminating))

        \func addToStartOfTrace {E : \Set} (x : E) (t : Process.Trace E) : Process.Trace E \elim t
          | inl a => inl (x :: a)
          | inr (l, terminating) => inr (x :: l, terminating)

        \func tracesAreFinite {E : \Set} (P : ProcessExpression E) : FiniteS (traces P)
        \elim P
          | STOP => FiniteS.single-finite
          | SKIP => FiniteS.finite-union FiniteS.single-finite FiniteS.single-finite
          | --> x P => FiniteS.finite-union
              (FiniteS.smap-finite (tracesAreFinite P))
              FiniteS.single-finite
          | ⊓ P Q => FiniteS.finite-union (tracesAreFinite P) (tracesAreFinite Q)
      }

    \func process-equiv \alias \infix 6 ≈ {E : \Set} (P Q : ProcessExpression E) : \Prop => traces P = traces Q

    \lemma example-equiv {E : \Set} (x : E) (P Q : ProcessExpression E) :
      ((x --> P) ⊓ (x --> Q)) ≈ (x --> (P ⊓ Q)) =>
      \let
        | f => traces.addToStartOfTrace x
        | A => (traces P) smap f
        | B => (traces Q) smap f
        | C => traces.emptyTrace
      \in
        traces ((x --> P) ⊓ (x --> Q))          ==< idp >==
        (traces (x --> P)) ∪ (traces (x --> Q)) ==< idp >==
        (A ∪ C) ∪ (B ∪ C)                       ==< ∪.union-cross A C B C >==
        (A ∪ B) ∪ (C ∪ C)                       ==< pmap ((A ∪ B) ∪ __) (∪.cancel C) >==
        (A ∪ B) ∪ C                             ==< pmap (__ ∪ C) (inv (∪.union-smap (traces P) (traces Q) f)) >==
        (((traces P) ∪ (traces Q)) smap f) ∪ C  ==< idp >==
        ((traces (P ⊓ Q)) smap f) ∪ C           ==< idp >==
        traces (x --> (P ⊓ Q))                  `qed
  }