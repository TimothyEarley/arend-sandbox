\import Arith.Nat
\import Data.Fin
\import Data.List \hiding (nil, ::)
\import Equiv
\import Function.Meta
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import lambda.unityped.Substitute
\open Context (∕∕)

\data Context (Type : \Type)
  | None \alias ∅
  | Cons \alias \infixl 6 ∕ (Context Type) Type

  \where {
    \func length {Type : \Type} (c : Context Type) : Nat \elim c
      | ∅ => 0
      | ∕ c t => suc (length c)

    \func toList {Type : \Set} (c : Context Type) : List Type \elim c
      | ∅ => List.nil
      | ∕ c t => toList c ++ t List.:: List.nil

    \func toReversedList {Type : \Set} (c : Context Type) : List Type \elim c
      | ∅ => List.nil
      | ∕ c t => t List.:: toReversedList c

    \func getAt {Type : \Set} (c : Context Type) (i : Fin (length c)) : Type \elim c, i
      | ∕ c t, 0 => t
      | ∕ c t, suc i => getAt c i

    \func toArray {Type : \Set} (c : Context Type) : Array Type => \new DArray {
      | len => length c
      | at => getAt c
    }

    \func fromArray {Type : \Set} (a : Array Type) : Context Type \elim a
      | nil => ∅
      | a :: l => fromArray l ∕ a

    \func eqArray {Type : \Set} : Context Type = Array Type => ext $
    \new QEquiv {
      | f => toArray
      | ret => fromArray
      | ret_f => fromTo
      | f_sec => toFrom
    }
      \where {
        \func fromTo (c : Context Type) : fromArray (toArray c) = c \elim c
          | ∅ => idp
          | ∕ c t => pmap (__ ∕ t) (fromTo _)

        \func toFrom (a : Array Type) : toArray (fromArray a) = a \elim a
          | nil => idp
          | a :: l => idp
      }

    \func Conss \alias \infixl 6 ∕∕ {Type : \Type} (c : Context Type) (a : Array Type) : Context Type \elim a
      | nil => c
      | a :: l => c ∕∕ l ∕ a

    \func lengthConss \alias length-∕∕ {Type : \Type} {c : Context Type} {a : Array Type} : length (c ∕∕ a) = length c Nat.+ a.len
    \elim a
      | nil => idp
      | a :: l => pmap suc length-∕∕
  }

\data Lookup \alias \infix 5 ∋ {Type : \1-Type} (c : Context Type) (T : Type) \elim c
  | ∕ c head => Z (head = T)
  | ∕ c head => S (c ∋ T)
  \where {
    \func toIndexReversed {Type : \Set} {c : Context Type} {T : Type} (l : c ∋ T) : Fin (Context.length c) \elim c, l
      | ∕ c head, Z p => zero
      | ∕ c head, S l => suc (toIndexReversed l)

    \func toIndex {Type : \Set} {c : Context Type} {T : Type} (l : c ∋ T) : Index (Context.toList c) \elim c, l
      | ∕ c head, Z p => expand-fin-right 0
      | ∕ c head, S l => expand-fin-left (toIndex l)

    \func indexOfList {Type : \Set} {c : Context Type} {T : Type} {l : c ∋ T} : Context.toList c !! toIndex l = T
    \elim c, l
      | ∕ c head, Z idp => expand-fin-right.correct 0
      | ∕ c head, S l => expand-fin-left.correct (toIndex l) *> indexOfList

    --    \func fromIndex {Type : \Set} {c : Context Type} (i : Index (Context.toList c)) : c ∋ (Context.toList c !! i) =>
    --      \let revI => revFin i
    --        | foo => {?}
    --      \in {?}
    --      \where {
    --        \func fromIndexWithReversed {Type : \Set} {c : Context Type} (i : Index (Context.toReversedList c)) : c ∋ (Context.toReversedList c !! i)
    --        \elim c, i
    --          | ∕ c1 t, 0 => Z idp
    --          | ∕ c1 t, suc f => S (fromIndexWithReversed f)
    --      }

    \func toIndexFin {Type : \Set} {c : Context Type} {T : Type} (l : c ∋ T) : Fin (Context.length c) \elim c, l
      | ∕ c1 head, Z p => zero
      | ∕ c1 head, S l => fsuc (toIndexFin l)

    \func fromIndexFin {Type : \Set} {c : Context Type}
                       (i : Fin (Context.length c))
      : c ∋ Context.getAt c i \elim  c, i
      | ∕ c1 t, 0 => Z idp
      | ∕ c1 t, suc i => S (fromIndexFin i)

    \func toFromIndexFin {Type : \Set} {c : Context Type} (i : Fin (Context.length c)) : toIndexFin (fromIndexFin i) = i
    \elim c, i
      | ∕ c1 t, 0 => idp
      | ∕ c1 t, suc i => pmap fsuc (toFromIndexFin i)
    -- fromToIndexFin is not as nice, since we loose info on type T

    \func firstConss {Type : \1-Type} {c : Context Type} {a : Array Type} {T : Type} (l : c ∋ T) : (c ∕∕ a) ∋ T
    \elim a
      | nil => l
      | a :: l1 => S (firstConss l)

    \func secondConss {Type : \1-Type} {c : Context Type} {l : Nat} {a : Array Type l} {T : Type}
                      (i : Fin l)
                      (h : a i = T)
      : (c ∕∕ a) ∋ T
    \elim l, a, i
      | suc l, a :: a1, 0 => Z h
      | suc l, a :: a1, suc i => S (secondConss i h)
  }

\meta #0 => Z idp

\meta #1 => S #0

\meta #2 => S #1

\meta #3 => S #2

\func Rename {Type : \1-Type} (gamma delta : Context Type) => \Pi {A : Type} (gamma ∋ A) -> delta ∋ A
  \where {
    \func id {Type : \1-Type} {gamma : Context Type} : Rename gamma gamma => \lam {A} l => l

    \func weaken {Type : \1-Type} {gamma : Context Type} {A : Type} : Rename gamma (gamma ∕ A) => \lam {_} => S

    \func compose {Type : \1-Type} {gamma delta epsilon : Context Type}
                  (r1 : Rename gamma delta) (r2 : Rename delta epsilon) : Rename gamma epsilon =>
      \lam {A} l => r2 (r1 l)

    \func extendCompose {Type : \1-Type} {gamma delta epsilon : Context Type}
                        {r1 : Rename gamma delta} {r2 : Rename delta epsilon} {A : Type}
      : extend (compose r1 r2) = {Rename (gamma ∕ A) (epsilon ∕ A)} compose (extend r1) (extend r2) =>
      ext (\lam {A1} l => \case \elim l \with {
        | Z p => idp
        | S l => idp
      })
  }

\func extend {Type : \1-Type} {gamma delta : Context Type} (h : Rename gamma delta) {B : Type}
  : Rename (gamma ∕ B) (delta ∕ B) => \lam h2 => \case \elim h2 \with {
  | Z p => Z p
  | S h2 => S (h h2)
}

\func Subst {Type : \1-Type} {Term : Context Type -> Type -> \1-Type} (gamma delta : Context Type) : \Type =>
  \Pi {A : Type} (gamma ∋ A) -> Term delta A

\class LC {Type : \1-Type} (\classifying Term : Context Type -> Type -> \1-Type) {
  | s-var {c : Context Type} {A : Type} (l : c ∋ A) : Term c A
}

\class SubstOperations \extends LC {
  | rename {gamma delta : Context Type} (h : Rename gamma delta)
           {A : Type} (t : Term gamma A) : Term delta A
  -- TODO maybe this can be auto derived

  | extends {gamma delta : Context Type} (h : Subst {_} {Term} gamma delta)
            {B : Type} : Subst {_} {Term} (gamma ∕ B) (delta ∕ B)
  | subst {gamma delta : Context Type} (s : Subst {_} {Term} gamma delta) {A : Type} (h : Term gamma A) : Term delta A
}

\func sub {SO : SubstOperations}
          {gamma : Context SO.Type} {A B : SO.Type}
          (t : SO.Term (gamma ∕ B) A) (t' : SO.Term gamma B) : SO.Term gamma A => subst (extendsOne t') t

  \where {
    \func extendsOne {SO : SubstOperations}
                     {gamma : Context SO.Type} {B : SO.Type} (t' : SO.Term gamma B) {A : SO.Type} (h : gamma ∕ B ∋ A) : SO.Term gamma A
    \elim h
      | Z p => rewriteI p t'
      | S h => s-var h
  }

\func sub2 {SO : SubstOperations}
           {gamma : Context SO.Type} {A B C : SO.Type}
           (t : SO.Term (gamma ∕ B ∕ C) A) (t' : SO.Term gamma B) (t'' : SO.Term gamma C) : SO.Term gamma A =>
  subst (extendsTwo t' t'') t
  \where {
    \func extendsTwo {SO : SubstOperations}
                     {gamma : Context SO.Type} {B C : SO.Type} (t' : SO.Term gamma B) (t'' : SO.Term gamma C)
                     {A : SO.Type} (h : gamma ∕ B ∕ C ∋ A) : SO.Term gamma A
    \elim h
      | Z idp => t''
      | S (Z idp) => t'
      | S (S h) => s-var h
  }

\func subN {SO : SubstOperations}
           {gamma : Context SO.Type} {A : SO.Type} {Bs : Array SO.Type}
           (t : SO.Term (gamma ∕∕ Bs) A)
           (t' :  DArray (\lam i => SO.Term gamma (Bs i)))
  : SO.Term gamma A => subst (extendsN t') t

  \where {
    \func extendsN {SO : SubstOperations}
                   {gamma : Context SO.Type} {Bs : Array SO.Type}
                   (t' :  DArray (\lam i => SO.Term gamma (Bs i))) {A : SO.Type}
                   (h : gamma ∕∕ Bs ∋ A) : SO.Term gamma A
    \elim Bs, t', h
      | nil, nil, h => s-var h
      | a :: _, x :: _, Z p => rewriteI p x
      | _ :: l, _ :: t', S h => extendsN t' h

    \func extendsNFirstConss {SO : SubstOperations}
                             {gamma : Context SO.Type} {Bs : Array SO.Type}
                             (t' : DArray (\lam i => SO.Term gamma (Bs i))) {A : SO.Type}
                             (l : gamma ∋ A)
      : extendsN {SO} t' (∋.firstConss {SO.Type} l) = s-var l
    \elim Bs, t'
      | nil, nil => idp
      | a :: l1, a1 :: t'1 => extendsNFirstConss _ l

    \func extendsNSecondConss {SO : SubstOperations}
                             {gamma : Context SO.Type} {Bs : Array SO.Type}
                             (t' : DArray (\lam i => SO.Term gamma (Bs i))) {A : SO.Type}
                             (i : Fin Bs.len)
      : extendsN {SO} t' (∋.secondConss {SO.Type} i idp) = t' i
    \elim Bs, t', i
      | a :: l, a1 :: t'1, 0 => idp
      | a :: l, a1 :: t'1, suc i => extendsNSecondConss t'1 {A} i
  }