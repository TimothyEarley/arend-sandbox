\import Logic
\import Paths
\import Paths.Meta
\import lambda.simplyTypedLambdaDeBruijne.Lambda
\import sets.MySet
\import sets.subset
\import lambda.GeneralContext \hiding (S, extends, rename, subst, ∅)
\import lambda.simplyTypedLambdaDeBruijne.Lambda
\import lambda.simplyTypedLambdaDeBruijne.Reduction
\import lambda.simplyTypedLambdaDeBruijne.Substitute

-- TS slides
-- https://github.com/AndrasKovacs/misc-stuff/blob/master/agda/STLCStrongNorm/StrongNorm.agda
-- https://people.mpi-sws.org/~dg/teaching/pt2012/sn.pdf

\data StronglyNormalizing {gamma : SimpleContext} {A : Type} (t : gamma ⊢ A)
  | sn (\Pi (t' : gamma ⊢ A) (x : t ->1 t') -> StronglyNormalizing t')
  \where {
    \func fromValue {gamma : SimpleContext} {A : Type} {t : gamma ⊢ A} (v : Value t) : StronglyNormalizing t =>
      sn (\lam t' x => absurd (Reduction.valueNoReduction v x.1))
    \func fromNormal {gamma : SimpleContext} {A : Type} {t : gamma ⊢ A} (n : Normal t) : StronglyNormalizing t =>
      sn (\lam t' x => absurd (n x.1))
  }

\func L {gamma : SimpleContext} (T : Type) : Ensemble (gamma ⊢ T) \elim T
  | Natural => StronglyNormalizing
  | --> A T => \lam f => \Pi {arg : gamma ⊢ A} (arg ∈ L A) -> (f ⋅ arg) ∈ L T

  \where {

    \func toSN {gamma : SimpleContext} {T : Type} : L {gamma} T ⊆ StronglyNormalizing \elim T
      | Natural => ⊆.refl
      | --> A T => {?}
  }

\func R (T : Type) : Ensemble (Context.∅ ⊢ T) \elim T
  | Natural => StronglyNormalizing
  | --> A T => \lam t => \Sigma (StronglyNormalizing t) (\Pi {arg : Context.∅ ⊢ A} (arg ∈ R A) -> (t ⋅ arg) ∈ R T)
\where {
  \func toSN {T : Type} : R T ⊆ StronglyNormalizing \elim T
    | Natural => ⊆.refl
    | --> A T => \lam {x} e => e.1
}

\func lemma3 {gamma : SimpleContext} {T : Type}
             (t : gamma ⊢ T)
             (s : SimpleSubst gamma Context.∅)
             (hs : \Pi {T' : Type} (l : gamma ∋ T') -> s l ∈ R T')
             : R T (subst s t) \elim T, t
  | Natural, zero => StronglyNormalizing.fromValue V-zero
  | Natural, succ t => {?}

  | Natural, var l => hs l
  | --> A T, var l => hs l

  | --> T T1, lam t => {?}

  | T, ⋅ t1 t2 => {?}

\func normalization {T : Type} (t : Context.∅ ⊢ T) : StronglyNormalizing t
  => \let r : R T t => transport (R T) substId (lemma3 t (\lam {A} l => var l) (\lam {T'} l => \case l)) \in R.toSN r
\where {
  \func substId {gamma : SimpleContext} {T : Type} {t : gamma ⊢ T} : subst (\lam {A} l => var l) t = t \elim T, t
    | Natural, var l => idp
    | --> A T, var l => idp
    | --> A B, lam h => pmap lam (transport (subst __ h = h) substId-lemma' substId)
    | Natural, ⋅ h1 h2 => pmap2 (⋅) substId substId
    | --> A B, ⋅ h1 h2 => pmap2 (⋅) substId substId
    | Natural, zero => idp
    | Natural, succ h => pmap succ substId

  \func substId-lemma {gamma : SimpleContext} {A : Type} {A' : Type} (l : gamma ∕ A ∋ A') : var l = {(gamma ∕ A) ⊢ A'} extends var l \elim A', l
    | _, Z p => idp
    | Natural, ∋.S l => idp
    | --> A1 A2, ∋.S l => idp

  \func substId-lemma' {gamma : SimpleContext} {A : Type} : var = {SimpleSubst (gamma ∕ A) (gamma ∕ A)} extends var =>
    ext substId-lemma

}