\import Function

-- https://lemonidas.github.io/pdf/DeeperShallowEmbeddings.pdf

\module Shallow \where {
  \func Ctx => \Type
    \where {
      \func empty : Ctx => \Sigma

      \func cons (C : Ctx) (T : Type C) : Ctx => \Sigma (c : C) (T c)
    }

  \func Type : Ctx -> \Type => \lam c => c -> \Type
    \where {
      \func Pi {C : Ctx} (T : Type C) (A : Type (Ctx.cons C T)) : Type C => \lam c => \Pi (t : T c) -> A (c, t)

      \func U {C : Ctx} : Type C => \lam c => \Type
    }

  \func Var (C : Ctx) (T : Type C) : \Type => \Pi (c : C) -> T c
    \where {
      \func same {C : Ctx} {T : Type C} : Var (Ctx.cons C T) (T o (\lam x => x.1)) => \lam c => c.2

      \func next {C : Ctx} {T A : Type C} (v : Var C A) : Var (Ctx.cons C T) (A o (\lam x => x.1)) => \lam c => v c.1
    }

  \func Term (C : Ctx) (T : Type C) : \Type => \Pi (c : C) -> T c
    \where {
      \func var {C : Ctx} {T : Type C} (v : Var C T) : Term C T => v

      \func lambda {C : Ctx} {A : Type C} {B : Type (Ctx.cons C A)} (t : Term (Ctx.cons C A) B) : Term C (Type.Pi A B) =>
        \lam c a => t (c, a)

      \func app {C : Ctx} {A : Type C} {B : Type (Ctx.cons C A)} (f : Term C (Type.Pi A B)) (arg : Term C A) : Term C (\lam c => B (c, arg c)) =>
        \lam c => (f c) (arg c)
    }

  \module Example \where {
    \func NatT {C : Ctx} : Type C => \lam c => Nat

    \func zeroNat {C : Ctx} : Term C NatT => \lam c => 0

    \func natId {C : Ctx} : Term C (Type.Pi NatT NatT) => Term.lambda (Term.var Var.same)

    \func useNatId : Term Ctx.empty NatT => Term.app {_} {_} {NatT} natId zeroNat

    \func evalUseNatId : useNatId () = 0 => idp

    \func polyId {C : Ctx} : Term C (Type.Pi Type.U (Type.Pi Var.same (Var.next Var.same))) =>
      Term.lambda {_} {_} {Type.Pi Var.same (Var.next Var.same)}
          (Term.lambda {_} {_} {Var.next Var.same}
              (Term.var Var.same))
  }
}