\import Logic
\import Paths.Meta
\import simplyTypedLambdaDeBruijne.GeneralContext
\import simplyTypedLambdaDeBruijne.Lambda

\func typeToProp (T : Type) : \Prop
  | Natural => TruncP Nat
  | --> A B => (typeToProp A) -> (typeToProp B)

\func RealisedContext (c : SimpleContext) => \Pi {T : Type} (l : c ∋ T) -> typeToProp T
\where {
  \func empty : RealisedContext ∅
    => \lam {T} l => \case l
  \func add {c : SimpleContext} (rc : RealisedContext c) {T : Type} (proof : typeToProp T) : RealisedContext (c ∕ T)
    => \lam {T1} l => \case l \with {
      | Z p => rewriteI p proof
      | S l1 => rc l1
    }
}

\func realise {c : SimpleContext} {T : Type} (t : c ⊢ T) (rc : RealisedContext c) : typeToProp T
  \elim T, t
    | Natural, zero => inP 0
    | Natural, succ t => \case realise t rc \with {
      | inP a => inP (suc a)
    }
    | T, var l => rc l
    | --> A B, lam t => \lam proofA => realise t (RealisedContext.add rc proofA)
    | B, ⋅ t1 t2 => (realise t1 rc) (realise t2 rc)

\where {
  \func realise0 (T : Type) (t : ∅ ⊢ T) : typeToProp T => realise t RealisedContext.empty

  \func example_trans (a b c : Type) :
    ((typeToProp a) -> (typeToProp b)) -> ((typeToProp b) -> (typeToProp c)) -> ((typeToProp a) -> (typeToProp c))
    => realise0 ((a --> b) --> (b --> c) --> (a --> c))
        (lam (lam (lam (#1 ⋅ (#2 ⋅ #0)))))
}