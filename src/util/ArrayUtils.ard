\import Algebra.Domain.Euclidean
\import Algebra.Monoid
\import Arith.Int
\import Arith.Nat
\import Category.Limit
\import Data.Array
\import Data.List (List)
\import Data.Maybe
\import Debug.Meta
\import Function.Meta
\import HLevel
\import LeipnizEquality
\import Logic
\import Logic.Meta
\import Meta
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Paths
\import Paths.Meta
\import Set (BaseSet, Dec, DecSet, no, yes)
\import Util
\import identity.DecMaps
\import identity.FinIdentity
\import identity.Identity
\import typeclasses.Functor
\import typeclasses.Monad
\open DArray (!!)
\open LeipnizIsEqual (i)
\open ArrayUtils (contains)

\module ArrayUtils \where {
  \func \infixl 9 ?? {A : \Type} (a : Array A) (i : Nat) : Maybe A \elim a, i
    | nil, _ => nothing
    | :: a arr, 0 => just a
    | :: a arr, suc i => arr ?? i
    \where {
      \func ++-left {A : \Type} {as as' : Array A} {x : A} {i : Nat} (h : as ?? i = just x) : (as ++ as') ?? i = just x
      \elim as, i, h
        | :: a arr, 0, h => h
        | :: a arr, suc i, h => ++-left h

      \func ++-right {A : \Type} {as as' : Array A} {x : A} {i : Nat} (h : as' ?? i = just x) : (as ++ as') ?? ((DArray.len {as}) + i) = just x
      \elim as
        | nil => h
        | :: a arr => ++-right h
    }

  \func \infixl 9 ??i {A : \Type} (a : Array A) (i : Int) : Maybe A \elim i
    | pos n => a ?? n
    | neg 0 => a ?? 0
    | neg (suc n) => nothing
    \where {
      \func ++-left {A : \Type} {as as' : Array A} {x : A} {i : Int} (h : as ??i i = just x) : (as ++ as') ??i i = just x
      \elim i
        | pos n => ??.++-left h
        | neg 0 => ??.++-left h
        | neg (suc n) => \case h

      \func ++-right {A : \Type} {as as' : Array A} {x : A} {i : Int} (h : as' ??i i = just x) : (as ++ as') ??i (pos (DArray.len {as}) + i) = just x
      \elim i
        | pos n => ??.++-right h
        | neg 0 => ??.++-right h
        | neg (suc n) => \case h
    }

  \func arrayOf {A : \Type} (val : A) {n : Nat} : Array A n => mkArray (\lam f => val)

  \func set {n : Nat} {A : \Type} (a : Array A n) (i : Fin n) (v : A) : Array A n =>
    \lam j => \case i fin≟ j \return A \with {
      | yes e => v
      | no n => a j
    }

    \where {
      \data Test | aTest | bTest | cTest | dTest

      \func test : set {3} (aTest :: bTest :: cTest :: nil) 1 dTest = aTest :: dTest :: cTest :: nil =>
        idp
    }

  \func maxOf {A : JoinSemilattice} {n : Nat} (l : Array A (suc n)) : \Sigma (m : A) (\Pi (x : A) (Index x l) -> x Order.PartialOrder.<= m)
  \elim n, l
    | 0, :: a nil => (a, \lam x (0, p) => rewrite p <=-reflexive)
    | suc n, :: a (:: a' l') \as l =>
      \let (m', h') => maxOf (a' :: l') \in (a ∨ m', \lam x (i : Index x l) => \case \elim x, \elim i \with {
        | _, (0, idp) => join-left
        | _, (suc i, idp) => <=-transitive (h' a' (0, idp)) join-right
      })

  \func All {A : \Type} (v : Array A) (P : A -> \Prop) : \Prop => Big (\lam a r => \Sigma (P a) r) (\Sigma) v
    \where {
      \func all++ {A : \Type} {v v' : Array A} {P : A -> \Prop} (h : All v P) (h' : All v' P) : All (v ++ v') P
      \elim v
        | nil => h'
        | :: a arr => (h.1, all++ h.2 h')
    }

  \func HasSome {A : \Type} {n : Nat} (v : Array A n) (P : A -> \Prop) : \Prop => ∃ (i : Fin n) (P (v i))

  \func toList {A : \Type} (a : Array A) : List A \elim a
    | nil => List.nil
    | :: a arr => a List.:: toList arr

  \func zipWithNext {A : \Type} {n : Nat} (v : Array A (suc n)) : Array (\Sigma A A) n \elim n, v
    | 0, :: a nil => nil
    | suc n, :: a (:: a' v) => (a, a') :: zipWithNext (a' :: v)

  \func ++-length {A : \Type} {xs ys : Array A} : DArray.len {xs} Nat.+ DArray.len {ys} = DArray.len {xs ++ ys} \elim xs
    | nil => idp
    | :: x xs => pmap suc ++-length

  \func dropLast {n : Nat} {A : Fin (suc n) -> \Type} (d : DArray {suc n} A) : DArray {n} (A __) =>
    d __ -- same function, we just don't use the last entry

  \func rev {n : Nat} {A : Fin n -> \Type} (d : DArray A) (i : Fin n) : Rev A i \elim n, d, i
    | suc n, d, 0 => d n
    | suc n, d, suc i => rev {n} {A __} (dropLast d) i
    \where {
      \func Rev {n : Nat} (A : Fin n -> \Type) (i : Fin n) : \Type \elim n, i
        | suc n, 0 => A n
        | suc n, suc i => Rev {n} (A __) i

      \func example : rev (1 :: 2 :: 3 :: nil) = {Array Nat} 3 :: 2 :: 1 :: nil => idp
    }

  \func headOr {A : \Type} (or : A) (d : Array A)  : A \elim d
    | nil => or
    | :: a arr => a

  \func tail {A : \Type} (d : Array A) : Array A \elim d
    | nil => nil
    | :: a d => d

  \func dTail {n : Nat} {A : Fin (suc n) -> \Type} (d : DArray A) : DArray (\lam i => A (suc i)) \elim d
    | :: a d => d

  \func append \alias \infixl 6 ::- {A : \Type} (d : Array A) (a : A) : Array A \elim d
    | nil => a :: nil
    | :: a' arr => a' :: (arr ::- a)
    \where {
      \func to++ {A : \Type} {l : Array A} {a : A} : l ::- a = l ++ (a :: nil) \elim l
        | nil => idp
        | :: a1 arr => pmap {Array A} (a1 :: __) to++

      \func compose++ {A : \Type} {l l' : Array A} {a : A} : l ::- a ++ l' = l ++ a :: l' \elim l
        | nil => idp
        | :: a1 arr => pmap {Array A} (a1 :: __) compose++

      \func notNil {A : \Type} {l : Array A} {a : A} : Not (l ::- a = nil) \elim l
        | nil => \case __
        | :: a1 arr => \case __

      \func heads= {A : \Type} {l l' : Array A} {a a' : A} (p : l ::- a = l' ::- a') : l = l' \elim l, l'
        | nil, nil => idp
        | nil, :: a1 arr => absurd $ notNil (inv $ pmap tail p)
        | :: a1 arr, nil => absurd $ notNil (pmap tail p)
        | :: a1 arr, :: a2 arr1 => pmap2 {A} {Array A} (__ :: __) (pmap (headOr a1) p) (heads= (pmap tail p))
    }

  \func contains {A : DecSet} (arr : Array A) (a : A) : Dec (TruncP (Index a arr))
  \elim arr
    | nil => no (\lam (inP (i, _)) => \case i)
    | :: a' arr => \case A.decideEq a' a \with {
      | yes e => yes (inP (0, e))
      | no n => decMap (contains arr a)
          (\lam (inP (i, h)) => inP (suc i, h),
           \lam h => \case \elim h \with {
             | inP (0, h) => absurd (n h)
             | inP (suc i, h) => inP (i, h)
           })
    }

  \func indexMap {A B : \Type} {b : B} (arr : Array A) (f : A -> B)
                 (h : Index b (map f arr))
    : \Sigma (a : A) (f a = b) (Index a arr) => (arr !! h.1, h.2, (h.1, idp))

  \func indexMap' {A B : \Type} {a : A} {arr : Array A} (f : A -> B)
                  (h : Index a arr)
    : Index (f a) (map f arr) => (h.1, pmap f h.2)
}

\func NoDup {A : \Type} (l : Array A) : \Type => \Pi (a : A) -> isProp (Index a l)
  \where {
    \func NoDup' {A : \Type} (l : Array A) : \Type \elim l
      | nil => \Sigma
      | :: a arr => \Sigma (Not (Index a arr)) (NoDup' arr)

    \func from' {A : \Set} {l : Array A} (h : NoDup' l) : NoDup l \elim l
      | nil => \lam a aIn aIn' => \case aIn \with {
      ((), _)
      }
      | :: a arr => \lam x aIn aIn' => \case \elim aIn, \elim aIn' \with {
        | (0, aIn), (0, aIn') => ext idp
        | (0, aIn), (suc i', aIn') => absurd (h.1 (i', aIn' *> (inv aIn)))
        | (suc i, aIn), (0, aIn') => absurd (h.1 (i, aIn *> (inv aIn')))
        | (suc i, aIn), (suc i', aIn') => \let rec => from' h.2 x (i, aIn) (i', aIn')
                                          \in ext (pmap fsuc (pmap __.1 rec))
      }

    \func remDup {A : DecSet} (l : Array A) : Array A \elim l
      | nil => nil
      | :: a arr => \case contains arr a \with {
        | yes a1 => remDup arr
        | no n => a :: (remDup arr)
      }
      \where {
        \func complete {A : DecSet} {a : A} {l : Array A} (h : Index a l) : TruncP (Index a (remDup l)) \elim l, h
          | nil, ((),p)
          | :: a1 arr, (0, p) => cases (contains arr a1) \with {
            | yes (inP e) => complete (transport (Index __ arr) p e)
            | no n => inP (0, p)
          }
          | :: a1 arr, (suc i,p) => cases (contains arr a1) \with {
            | yes (inP e) => complete (i, p)
            | no n => \case complete (i, p) \with {
              | inP (i', p') => inP (suc i', p')
            }
          }

        \func sound {A : DecSet} {a : A} {l : Array A} (h : Index a (remDup l)) : Index a l \elim l, h
          | nil, ((),p)
          | :: a1 arr, h => sound-lemma (contains arr a1) h
          \where {
            \func sound-lemma {A : DecSet} {a a1 : A} {arr : Array A} (in? : Dec (TruncP (Index a1 arr))) (h : Index a (\case in? \with {
              | yes a2 => remDup arr
              | no n => a1 :: remDup arr
            })) : Index a (a1 :: arr) \elim in?, h
              | yes _, h => \let s' => sound h \in (suc s'.1, s'.2)
              | no _, (0, p) => (0, p)
              | no _, (suc i, p) => \let s' => sound (i, p) \in (suc s'.1, s'.2)
          }

        \func progress {A : DecSet} {l : Array A} : NoDup (remDup l) => NoDup.from' progress'
          \where {
            \func progress' {A : DecSet} {l : Array A} : NoDup' (remDup l) \elim l
              | nil => ()
              | :: a arr => mcases \with {
                | yes a1 => progress'
                | no n => (\lam i => n (inP $ sound i), progress')
              }
          }
      }
  }

\func ArrayOrder {A : \Set} : Preorder (Array A) \cowith
  | <= => <=
  | <=-reflexive => refl
  | <=-transitive => trans
\where {
  \data  \infix 6 <= {A : \Type} (x y : Array A) \elim x, y
    | nil, _ => nil<=_
    | :: a t, :: a' t' => cons<=cons (a = a') (t <= t')

  \func refl {A : \Type} {x : Array A} : x <= x \elim x
    | nil => nil<=_
    | :: a arr => cons<=cons idp refl

  \func trans {A : \Type} {x y z : Array A} (h : x <= y) (h' : y <= z) : x <= z
    \elim x, y, z, h, h'
      | nil, _, _, _, _ => nil<=_
      | :: a t, :: a1 t1, :: a' t', cons<=cons p h, cons<=cons p1 h' =>
        cons<=cons (p *> p1) (trans h h')

  \func <=-prefix {A : \Type} {x y : Array A} (h : x <= y) : \Sigma (z : Array A) (x ++ z = y)
    \elim x, y, h
      | nil, y, nil<=_ => (y, idp)
      | :: a t, :: a' t', cons<=cons p h => \let (z, h') => <=-prefix h
                                            \in (z, pmap2 {A} {Array A} (__ :: __) p h')
}